set client_min_messages = error;
SET CLIENT_ENCODING='UTF8';
set current_schema=swtest;
/* invalid data type */
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME,'|'),CONNECT_BY_ROOT(NAME),ID,CHA,VCH,TEX,DAT,TIM,TIS,PID,PCHA,PVCH,PTEX,PDAT,PTIM,PTIS
FROM TEST_HCB_FQB
START WITH ID=1
CONNECT BY prior ID=PID
ORDER SIBLINGS BY NAME ASC;
  name  | level | connect_by_isleaf |        sys_connect_by_path        | connect_by_root | id  |    cha     | vch | tex |           dat            |   tim    |           tis            | pid |    pcha    | pvch | ptex |           pdat           |   ptim   |           ptis           
--------+-------+-------------------+-----------------------------------+-----------------+-----+------------+-----+-----+--------------------------+----------+--------------------------+-----+------------+------+------+--------------------------+----------+--------------------------
 中国   |     1 |                 0 | |中国                             | 中国            |   1 | a          | a   | a   | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021 |   0 | 0          | 0    | 0    | Tue Dec 12 12:12:12 2000 | 00:00:01 | Tue Dec 12 12:12:12 2000
 安徽省 |     2 |                 1 | |中国|安徽省                      | 中国            |  13 | ac         | ac  | ac  | Fri Jan 01 01:01:02 2021 | 01:01:02 | Fri Jan 01 01:01:02 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 山东省 |     2 |                 1 | |中国|山东省                      | 中国            |  12 | ab         | ab  | ab  | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 武汉省 |     2 |                 1 | |中国|武汉省                      | 中国            |  19 | ai         | ai  | ai  | Fri Jan 01 01:01:09 2021 | 01:01:09 | Fri Jan 01 01:01:09 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 江苏省 |     2 |                 0 | |中国|江苏省                      | 中国            |  11 | aa         | aa  | aa  | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 南京市 |     3 |                 0 | |中国|江苏省|南京市               | 中国            | 111 | aaa        | aaa | aaa | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 六合区 |     4 |                 1 | |中国|江苏省|南京市|六合区        | 中国            | 129 | abi        | abi | abi | Fri Jan 01 01:01:28 2021 | 01:01:28 | Fri Jan 01 01:01:28 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 建邺区 |     4 |                 1 | |中国|江苏省|南京市|建邺区        | 中国            | 125 | abe        | abe | abe | Fri Jan 01 01:01:24 2021 | 01:01:24 | Fri Jan 01 01:01:24 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 江宁区 |     4 |                 0 | |中国|江苏省|南京市|江宁区        | 中国            | 121 | aba        | aba | aba | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 东山街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|东山街 | 中国            | 131 | aca        | aca | aca | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 横溪街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|横溪街 | 中国            | 139 | aci        | aci | aci | Fri Jan 01 01:01:38 2021 | 01:01:38 | Fri Jan 01 01:01:38 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 江宁街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|江宁街 | 中国            | 136 | acf        | acf | acf | Fri Jan 01 01:01:35 2021 | 01:01:35 | Fri Jan 01 01:01:35 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 汤山街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|汤山街 | 中国            | 133 | acc        | acc | acc | Fri Jan 01 01:01:32 2021 | 01:01:32 | Fri Jan 01 01:01:32 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 淳化街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|淳化街 | 中国            | 134 | acd        | acd | acd | Fri Jan 01 01:01:33 2021 | 01:01:33 | Fri Jan 01 01:01:33 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 湖熟街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|湖熟街 | 中国            | 138 | ach        | ach | ach | Fri Jan 01 01:01:37 2021 | 01:01:37 | Fri Jan 01 01:01:37 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 禄口街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|禄口街 | 中国            | 135 | ace        | ace | ace | Fri Jan 01 01:01:34 2021 | 01:01:34 | Fri Jan 01 01:01:34 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 秣陵街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|秣陵街 | 中国            | 132 | acb        | acb | acb | Fri Jan 01 01:01:31 2021 | 01:01:31 | Fri Jan 01 01:01:31 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 谷里街 |     5 |                 1 | |中国|江苏省|南京市|江宁区|谷里街 | 中国            | 137 | acg        | acg | acg | Fri Jan 01 01:01:36 2021 | 01:01:36 | Fri Jan 01 01:01:36 2021 | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 浦口区 |     4 |                 1 | |中国|江苏省|南京市|浦口区        | 中国            | 127 | abg        | abg | abg | Fri Jan 01 01:01:26 2021 | 01:01:26 | Fri Jan 01 01:01:26 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 浦口区 |     4 |                 1 | |中国|江苏省|南京市|浦口区        | 中国            | 128 | abh        | abh | abh | Fri Jan 01 01:01:27 2021 | 01:01:27 | Fri Jan 01 01:01:27 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 玄武区 |     4 |                 1 | |中国|江苏省|南京市|玄武区        | 中国            | 124 | abd        | abd | abd | Fri Jan 01 01:01:23 2021 | 01:01:23 | Fri Jan 01 01:01:23 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 秦淮区 |     4 |                 1 | |中国|江苏省|南京市|秦淮区        | 中国            | 126 | abf        | abf | abf | Fri Jan 01 01:01:25 2021 | 01:01:25 | Fri Jan 01 01:01:25 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 雨花台 |     4 |                 1 | |中国|江苏省|南京市|雨花台        | 中国            | 122 | abb        | abb | abb | Fri Jan 01 01:01:21 2021 | 01:01:21 | Fri Jan 01 01:01:21 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 鼓楼区 |     4 |                 1 | |中国|江苏省|南京市|鼓楼区        | 中国            | 123 | abc        | abc | abc | Fri Jan 01 01:01:22 2021 | 01:01:22 | Fri Jan 01 01:01:22 2021 | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 宿迁市 |     3 |                 1 | |中国|江苏省|宿迁市               | 中国            | 112 | aab        | aab | aab | Fri Jan 01 01:01:11 2021 | 01:01:11 | Fri Jan 01 01:01:11 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 常州市 |     3 |                 1 | |中国|江苏省|常州市               | 中国            | 117 | aag        | aag | aag | Fri Jan 01 01:01:16 2021 | 01:01:16 | Fri Jan 01 01:01:16 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 徐州市 |     3 |                 1 | |中国|江苏省|徐州市               | 中国            | 113 | aac        | aac | aac | Fri Jan 01 01:01:12 2021 | 01:01:12 | Fri Jan 01 01:01:12 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 无锡市 |     3 |                 1 | |中国|江苏省|无锡市               | 中国            | 116 | aaf        | aaf | aaf | Fri Jan 01 01:01:15 2021 | 01:01:15 | Fri Jan 01 01:01:15 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 泰州市 |     3 |                 1 | |中国|江苏省|泰州市               | 中国            | 119 | aai        | aai | aai | Fri Jan 01 01:01:18 2021 | 01:01:18 | Fri Jan 01 01:01:18 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 盐城市 |     3 |                 1 | |中国|江苏省|盐城市               | 中国            | 115 | aae        | aae | aae | Fri Jan 01 01:01:14 2021 | 01:01:14 | Fri Jan 01 01:01:14 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 苏州市 |     3 |                 1 | |中国|江苏省|苏州市               | 中国            | 114 | aad        | aad | aad | Fri Jan 01 01:01:13 2021 | 01:01:13 | Fri Jan 01 01:01:13 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 连云港 |     3 |                 1 | |中国|江苏省|连云港               | 中国            | 118 | aah        | aah | aah | Fri Jan 01 01:01:17 2021 | 01:01:17 | Fri Jan 01 01:01:17 2021 |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 河北省 |     2 |                 1 | |中国|河北省                      | 中国            |  15 | ae         | ae  | ae  | Fri Jan 01 01:01:05 2021 | 01:01:05 | Fri Jan 01 01:01:05 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 河南省 |     2 |                 1 | |中国|河南省                      | 中国            |  14 | ad         | ad  | ad  | Fri Jan 01 01:01:03 2021 | 01:01:03 | Fri Jan 01 01:01:03 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 湖北省 |     2 |                 1 | |中国|湖北省                      | 中国            |  17 | ag         | ag  | ag  | Fri Jan 01 01:01:07 2021 | 01:01:07 | Fri Jan 01 01:01:07 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 湖南省 |     2 |                 1 | |中国|湖南省                      | 中国            |  16 | af         | af  | af  | Fri Jan 01 01:01:06 2021 | 01:01:06 | Fri Jan 01 01:01:06 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 贵州省 |     2 |                 1 | |中国|贵州省                      | 中国            |  18 | ah         | ah  | ah  | Fri Jan 01 01:01:08 2021 | 01:01:08 | Fri Jan 01 01:01:08 2021 |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
(37 rows)

-- invalid use connect_by_root, will treate it as regular column report column does not exists error 
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME,'|'),CONNECT_BY_ROOT
FROM test_hcb_ptb
START WITH (ID=169 or ID=168) and CHA in ('afi','afg','afh')
CONNECT BY ID=PRIOR PID and CHA=PRIOR PCHA and VCH=PRIOR PVCH and DAT=PRIOR PDAT and TIM=PRIOR PTIM AND TIS=PRIOR PTIS
order by 1;
ERROR:  column "connect_by_root" does not exist
LINE 1: ...L,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME,'|'),CONNECT_BY...
                                                             ^
CONTEXT:  referenced column: connect_by_root
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME,'|'),CONNECT_BY_ROOT name
FROM test_hcb_ptb
START WITH (ID=169 or ID=168) and CHA in ('afi','afg','afh')
CONNECT BY ID=PRIOR PID and CHA=PRIOR PCHA and VCH=PRIOR PVCH and DAT=PRIOR PDAT and TIM=PRIOR PTIM AND TIS=PRIOR PTIS
order by 1;
   name   | level | connect_by_isleaf | sys_connect_by_path |   name   
----------+-------+-------------------+---------------------+----------
 第九单元 |     1 |                 1 | |第九单元           | 第九单元
 第八单元 |     1 |                 1 | |第八单元           | 第八单元
(2 rows)

SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME,'|'),CONNECT_BY_ROOT(name)
FROM test_hcb_ptb
START WITH (ID=169 or ID=168) and CHA in ('afi','afg','afh')
CONNECT BY ID=PRIOR PID and CHA=PRIOR PCHA and VCH=PRIOR PVCH and DAT=PRIOR PDAT and TIM=PRIOR PTIM AND TIS=PRIOR PTIS
order by 1;
   name   | level | connect_by_isleaf | sys_connect_by_path | connect_by_root 
----------+-------+-------------------+---------------------+-----------------
 第九单元 |     1 |                 1 | |第九单元           | 第九单元
 第八单元 |     1 |                 1 | |第八单元           | 第八单元
(2 rows)

/* Unsupported StartWith Scenarios */
explain(costs off)
select * from test_hcb_ptbc t1 start with t1.id = 11 connect by prior t1.id = t1.pid;
                              QUERY PLAN                               
-----------------------------------------------------------------------
 CTE Scan on tmp_reuslt
   CTE tmp_reuslt
     ->  StartWith Operator
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union
                 ->  Row Adapter
                       ->  CStore Scan on test_hcb_ptbc t1
                             Filter: (id = 11)
                 ->  Hash Join
                       Hash Cond: (t1.pid = tmp_reuslt."t1@id")
                       ->  Materialize
                             ->  Row Adapter
                                   ->  CStore Scan on test_hcb_ptbc t1
                       ->  Hash
                             ->  WorkTable Scan on tmp_reuslt
(15 rows)

select * from test_hcb_ptbc t1 start with t1.id = 11 connect by prior t1.id = t1.pid;
 id  |    cha     | vch  | tex |           dat            |   tim    |           tis            |   name   | pid |    pcha    | pvch | ptex |           pdat           |   ptim   |           ptis           
-----+------------+------+-----+--------------------------+----------+--------------------------+----------+-----+------------+------+------+--------------------------+----------+--------------------------
  11 | aa         |  aa  | aa  | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021 | 江苏省   |   1 | a          | a    | a    | Sun Dec 12 12:12:12 2021 | 12:12:12 | Sun Dec 12 12:12:12 2021
 111 | aaa        |  aaa | aaa | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021 | 南京市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 112 | aab        |  aab | aab | Fri Jan 01 01:01:11 2021 | 01:01:11 | Fri Jan 01 01:01:11 2021 | 宿迁市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 113 | aac        |  aac | aac | Fri Jan 01 01:01:12 2021 | 01:01:12 | Fri Jan 01 01:01:12 2021 | 徐州市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 114 | aad        |  aad | aad | Fri Jan 01 01:01:13 2021 | 01:01:13 | Fri Jan 01 01:01:13 2021 | 苏州市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 115 | aae        |  aae | aae | Fri Jan 01 01:01:14 2021 | 01:01:14 | Fri Jan 01 01:01:14 2021 | 盐城市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 117 | aag        |  aag | aag | Fri Jan 01 01:01:16 2021 | 01:01:16 | Fri Jan 01 01:01:16 2021 | 常州市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 116 | aaf        |  aaf | aaf | Fri Jan 01 01:01:15 2021 | 01:01:15 | Fri Jan 01 01:01:15 2021 | 无锡市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 118 | aah        |  aah | aah | Fri Jan 01 01:01:17 2021 | 01:01:17 | Fri Jan 01 01:01:17 2021 | 连云港   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 119 | aai        |  aai | aai | Fri Jan 01 01:01:18 2021 | 01:01:18 | Fri Jan 01 01:01:18 2021 | 泰州市   |  11 | aa         | aa   | aa   | Fri Jan 01 01:01:01 2021 | 01:01:01 | Fri Jan 01 01:01:01 2021
 121 | aba        |  aba | aba | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021 | 江宁区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 122 | abb        |  abb | abb | Fri Jan 01 01:01:21 2021 | 01:01:21 | Fri Jan 01 01:01:21 2021 | 雨花台   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 123 | abc        |  abc | abc | Fri Jan 01 01:01:22 2021 | 01:01:22 | Fri Jan 01 01:01:22 2021 | 鼓楼区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 124 | abd        |  abd | abd | Fri Jan 01 01:01:23 2021 | 01:01:23 | Fri Jan 01 01:01:23 2021 | 玄武区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 125 | abe        |  abe | abe | Fri Jan 01 01:01:24 2021 | 01:01:24 | Fri Jan 01 01:01:24 2021 | 建邺区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 126 | abf        |  abf | abf | Fri Jan 01 01:01:25 2021 | 01:01:25 | Fri Jan 01 01:01:25 2021 | 秦淮区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 127 | abg        |  abg | abg | Fri Jan 01 01:01:26 2021 | 01:01:26 | Fri Jan 01 01:01:26 2021 | 浦口区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 128 | abh        |  abh | abh | Fri Jan 01 01:01:27 2021 | 01:01:27 | Fri Jan 01 01:01:27 2021 | 浦口区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 129 | abi        |  abi | abi | Fri Jan 01 01:01:28 2021 | 01:01:28 | Fri Jan 01 01:01:28 2021 | 六合区   | 111 | aaa        | aaa  | aaa  | Fri Jan 01 01:01:10 2021 | 01:01:10 | Fri Jan 01 01:01:10 2021
 131 | aca        |  aca | aca | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021 | 东山街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 132 | acb        |  acb | acb | Fri Jan 01 01:01:31 2021 | 01:01:31 | Fri Jan 01 01:01:31 2021 | 秣陵街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 133 | acc        |  acc | acc | Fri Jan 01 01:01:32 2021 | 01:01:32 | Fri Jan 01 01:01:32 2021 | 汤山街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 135 | ace        |  ace | ace | Fri Jan 01 01:01:34 2021 | 01:01:34 | Fri Jan 01 01:01:34 2021 | 禄口街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 134 | acd        |  acd | acd | Fri Jan 01 01:01:33 2021 | 01:01:33 | Fri Jan 01 01:01:33 2021 | 淳化街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 136 | acf        |  acf | acf | Fri Jan 01 01:01:35 2021 | 01:01:35 | Fri Jan 01 01:01:35 2021 | 江宁街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 137 | acg        |  acg | acg | Fri Jan 01 01:01:36 2021 | 01:01:36 | Fri Jan 01 01:01:36 2021 | 谷里街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 138 | ach        |  ach | ach | Fri Jan 01 01:01:37 2021 | 01:01:37 | Fri Jan 01 01:01:37 2021 | 湖熟街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 139 | aci        |  aci | aci | Fri Jan 01 01:01:38 2021 | 01:01:38 | Fri Jan 01 01:01:38 2021 | 横溪街   | 121 | aba        | aba  | aba  | Fri Jan 01 01:01:20 2021 | 01:01:20 | Fri Jan 01 01:01:20 2021
 141 | ada        |  ada | ada | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021 | 江南摩卡 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 142 | adb        |  adb | adb | Fri Jan 01 01:01:41 2021 | 01:01:41 | Fri Jan 01 01:01:41 2021 | 四季云顶 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 143 | adc        |  adc | adc | Fri Jan 01 01:01:42 2021 | 01:01:42 | Fri Jan 01 01:01:42 2021 | 盛世江南 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 144 | add        |  add | add | Fri Jan 01 01:01:43 2021 | 01:01:43 | Fri Jan 01 01:01:43 2021 | 七里香都 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 145 | ade        |  ade | ade | Fri Jan 01 01:01:44 2021 | 01:01:44 | Fri Jan 01 01:01:44 2021 | 西山枫林 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 146 | adf        |  adf | adf | Fri Jan 01 01:01:45 2021 | 01:01:45 | Fri Jan 01 01:01:45 2021 | 醉墨小镇 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 147 | adg        |  adg | adg | Fri Jan 01 01:01:46 2021 | 01:01:46 | Fri Jan 01 01:01:46 2021 | 布拉格调 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 148 | adh        |  adh | adh | Fri Jan 01 01:01:47 2021 | 01:01:47 | Fri Jan 01 01:01:47 2021 | 清幽别院 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 149 | adi        |  adi | adi | Fri Jan 01 01:01:48 2021 | 01:01:48 | Fri Jan 01 01:01:48 2021 | 璀璨天城 | 131 | aca        | aca  | aca  | Fri Jan 01 01:01:30 2021 | 01:01:30 | Fri Jan 01 01:01:30 2021
 151 | aea        |  aea | aea | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021 | 江南一楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 152 | aeb        |  aeb | aeb | Fri Jan 01 01:01:51 2021 | 01:01:51 | Fri Jan 01 01:01:51 2021 | 江南二楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 153 | aec        |  aec | aec | Fri Jan 01 01:01:52 2021 | 01:01:52 | Fri Jan 01 01:01:52 2021 | 江南三楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 154 | aed        |  aed | aed | Fri Jan 01 01:01:53 2021 | 01:01:53 | Fri Jan 01 01:01:53 2021 | 江南四楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 155 | aee        |  aee | aee | Fri Jan 01 01:01:54 2021 | 01:01:54 | Fri Jan 01 01:01:54 2021 | 江南五楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 156 | aef        |  aef | aef | Fri Jan 01 01:01:55 2021 | 01:01:55 | Fri Jan 01 01:01:55 2021 | 江南六楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 157 | aeg        |  aeg | aeg | Fri Jan 01 01:01:56 2021 | 01:01:56 | Fri Jan 01 01:01:56 2021 | 江南七楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 158 | aeh        |  aeh | aeh | Fri Jan 01 01:01:57 2021 | 01:01:57 | Fri Jan 01 01:01:57 2021 | 江南八楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 159 | aei        |  aei | aei | Fri Jan 01 01:01:58 2021 | 01:01:58 | Fri Jan 01 01:01:58 2021 | 江南九楼 | 141 | ada        | ada  | ada  | Fri Jan 01 01:01:40 2021 | 01:01:40 | Fri Jan 01 01:01:40 2021
 161 | afa        |  afa | afa | Fri Jan 01 01:02:50 2021 | 01:02:50 | Fri Jan 01 01:02:50 2021 | 第一单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 162 | afb        |  afb | afb | Fri Jan 01 01:02:51 2021 | 01:02:51 | Fri Jan 01 01:02:51 2021 | 第二单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 163 | afc        |  afc | afc | Fri Jan 01 01:02:52 2021 | 01:02:52 | Fri Jan 01 01:02:52 2021 | 第三单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 164 | afd        |  afd | afd | Fri Jan 01 01:02:53 2021 | 01:02:53 | Fri Jan 01 01:02:53 2021 | 第四单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 165 | afe        |  afe | afe | Fri Jan 01 01:02:54 2021 | 01:02:54 | Fri Jan 01 01:02:54 2021 | 第五单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 166 | aff        |  aff | aff | Fri Jan 01 01:02:55 2021 | 01:02:55 | Fri Jan 01 01:02:55 2021 | 第六单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 167 | afg        |  afg | afg | Fri Jan 01 01:02:56 2021 | 01:02:56 | Fri Jan 01 01:02:56 2021 | 第七单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 168 | afh        |  afh | afh | Fri Jan 01 01:02:57 2021 | 01:02:57 | Fri Jan 01 01:02:57 2021 | 第八单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
 169 | afi        |  afi | afi | Fri Jan 01 01:02:58 2021 | 01:02:58 | Fri Jan 01 01:02:58 2021 | 第九单元 | 151 | aea        | aea  | aea  | Fri Jan 01 01:01:50 2021 | 01:01:50 | Fri Jan 01 01:01:50 2021
(55 rows)

SELECT t1.id,t1.pid,t1.name,level FROM test_hcb_ptb t1,test_hcb_ptb t2 WHERE t1.id=t2.id START WITH t1.id=141 CONNECT BY PRIOR t1.id=t1.pid FOR UPDATE OF t2 NOWAIT;
ERROR:  Syntax error found.
LINE 1: ...TART WITH t1.id=141 CONNECT BY PRIOR t1.id=t1.pid FOR UPDATE...
                                                             ^
DETAIL:  FOR UPDATE/SHARE cannot be used with START WITH CONNECT BY clauses
SELECT t1.id, t1.pid,t1.name,level FROM core_066 t1 START WITH id = 117 CONNECT BY PRIOR id=pid FOR UPDATE;
ERROR:  Syntax error found.
LINE 1: ...66 t1 START WITH id = 117 CONNECT BY PRIOR id=pid FOR UPDATE...
                                                             ^
DETAIL:  FOR UPDATE/SHARE cannot be used with START WITH CONNECT BY clauses
/* connect by root scenarios */
select pid x,id,CONNECT_BY_ROOT ID from test_hcb_ptbc t1 start with id = 11 connect by prior id = pid;
  x  | id  | connect_by_rootid 
-----+-----+-------------------
   1 |  11 | 11
  11 | 111 | 11
  11 | 112 | 11
  11 | 113 | 11
  11 | 114 | 11
  11 | 115 | 11
  11 | 117 | 11
  11 | 116 | 11
  11 | 118 | 11
  11 | 119 | 11
 111 | 121 | 11
 111 | 122 | 11
 111 | 123 | 11
 111 | 124 | 11
 111 | 125 | 11
 111 | 126 | 11
 111 | 127 | 11
 111 | 128 | 11
 111 | 129 | 11
 121 | 131 | 11
 121 | 132 | 11
 121 | 133 | 11
 121 | 135 | 11
 121 | 134 | 11
 121 | 136 | 11
 121 | 137 | 11
 121 | 138 | 11
 121 | 139 | 11
 131 | 141 | 11
 131 | 142 | 11
 131 | 143 | 11
 131 | 144 | 11
 131 | 145 | 11
 131 | 146 | 11
 131 | 147 | 11
 131 | 148 | 11
 131 | 149 | 11
 141 | 151 | 11
 141 | 152 | 11
 141 | 153 | 11
 141 | 154 | 11
 141 | 155 | 11
 141 | 156 | 11
 141 | 157 | 11
 141 | 158 | 11
 141 | 159 | 11
 151 | 161 | 11
 151 | 162 | 11
 151 | 163 | 11
 151 | 164 | 11
 151 | 165 | 11
 151 | 166 | 11
 151 | 167 | 11
 151 | 168 | 11
 151 | 169 | 11
(55 rows)

select pid x,id,CONNECT_BY_ROOT ID alias_id from test_hcb_ptbc t1 start with id = 11 connect by prior id = pid;
  x  | id  | alias_id 
-----+-----+----------
   1 |  11 | 11
  11 | 111 | 11
  11 | 112 | 11
  11 | 113 | 11
  11 | 114 | 11
  11 | 115 | 11
  11 | 117 | 11
  11 | 116 | 11
  11 | 118 | 11
  11 | 119 | 11
 111 | 121 | 11
 111 | 122 | 11
 111 | 123 | 11
 111 | 124 | 11
 111 | 125 | 11
 111 | 126 | 11
 111 | 127 | 11
 111 | 128 | 11
 111 | 129 | 11
 121 | 131 | 11
 121 | 132 | 11
 121 | 133 | 11
 121 | 135 | 11
 121 | 134 | 11
 121 | 136 | 11
 121 | 137 | 11
 121 | 138 | 11
 121 | 139 | 11
 131 | 141 | 11
 131 | 142 | 11
 131 | 143 | 11
 131 | 144 | 11
 131 | 145 | 11
 131 | 146 | 11
 131 | 147 | 11
 131 | 148 | 11
 131 | 149 | 11
 141 | 151 | 11
 141 | 152 | 11
 141 | 153 | 11
 141 | 154 | 11
 141 | 155 | 11
 141 | 156 | 11
 141 | 157 | 11
 141 | 158 | 11
 141 | 159 | 11
 151 | 161 | 11
 151 | 162 | 11
 151 | 163 | 11
 151 | 164 | 11
 151 | 165 | 11
 151 | 166 | 11
 151 | 167 | 11
 151 | 168 | 11
 151 | 169 | 11
(55 rows)

select pid x,id,CONNECT_BY_ROOT t1.ID from test_hcb_ptbc t1 start with id = 11 connect by prior id = pid;
  x  | id  | connect_by_roott1.id 
-----+-----+----------------------
   1 |  11 | 11
  11 | 111 | 11
  11 | 112 | 11
  11 | 113 | 11
  11 | 114 | 11
  11 | 115 | 11
  11 | 117 | 11
  11 | 116 | 11
  11 | 118 | 11
  11 | 119 | 11
 111 | 121 | 11
 111 | 122 | 11
 111 | 123 | 11
 111 | 124 | 11
 111 | 125 | 11
 111 | 126 | 11
 111 | 127 | 11
 111 | 128 | 11
 111 | 129 | 11
 121 | 131 | 11
 121 | 132 | 11
 121 | 133 | 11
 121 | 135 | 11
 121 | 134 | 11
 121 | 136 | 11
 121 | 137 | 11
 121 | 138 | 11
 121 | 139 | 11
 131 | 141 | 11
 131 | 142 | 11
 131 | 143 | 11
 131 | 144 | 11
 131 | 145 | 11
 131 | 146 | 11
 131 | 147 | 11
 131 | 148 | 11
 131 | 149 | 11
 141 | 151 | 11
 141 | 152 | 11
 141 | 153 | 11
 141 | 154 | 11
 141 | 155 | 11
 141 | 156 | 11
 141 | 157 | 11
 141 | 158 | 11
 141 | 159 | 11
 151 | 161 | 11
 151 | 162 | 11
 151 | 163 | 11
 151 | 164 | 11
 151 | 165 | 11
 151 | 166 | 11
 151 | 167 | 11
 151 | 168 | 11
 151 | 169 | 11
(55 rows)

select pid x,id,CONNECT_BY_ROOT t1.ID alias_id from test_hcb_ptbc t1 start with id = 11 connect by prior id = pid;
  x  | id  | alias_id 
-----+-----+----------
   1 |  11 | 11
  11 | 111 | 11
  11 | 112 | 11
  11 | 113 | 11
  11 | 114 | 11
  11 | 115 | 11
  11 | 117 | 11
  11 | 116 | 11
  11 | 118 | 11
  11 | 119 | 11
 111 | 121 | 11
 111 | 122 | 11
 111 | 123 | 11
 111 | 124 | 11
 111 | 125 | 11
 111 | 126 | 11
 111 | 127 | 11
 111 | 128 | 11
 111 | 129 | 11
 121 | 131 | 11
 121 | 132 | 11
 121 | 133 | 11
 121 | 135 | 11
 121 | 134 | 11
 121 | 136 | 11
 121 | 137 | 11
 121 | 138 | 11
 121 | 139 | 11
 131 | 141 | 11
 131 | 142 | 11
 131 | 143 | 11
 131 | 144 | 11
 131 | 145 | 11
 131 | 146 | 11
 131 | 147 | 11
 131 | 148 | 11
 131 | 149 | 11
 141 | 151 | 11
 141 | 152 | 11
 141 | 153 | 11
 141 | 154 | 11
 141 | 155 | 11
 141 | 156 | 11
 141 | 157 | 11
 141 | 158 | 11
 141 | 159 | 11
 151 | 161 | 11
 151 | 162 | 11
 151 | 163 | 11
 151 | 164 | 11
 151 | 165 | 11
 151 | 166 | 11
 151 | 167 | 11
 151 | 168 | 11
 151 | 169 | 11
(55 rows)

/* infinite loop issues */
SELECT LEVEL,NAME,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME, '/'),CONNECT_BY_ROOT(ID)
FROM test_swcb_a
START WITH ID='00118'
CONNECT BY PRIOR ID=PID
ORDER SIBLINGS BY NAME;
ERROR:  START WITH .. CONNECT BY statement runs into cycle exception
/* fromlist startwith for single table  */
select t1.ID,t1.VCH,pid,NAME,PTEX from TEST_HCB_FQB t1,TEST_SUBLINK t2 where t1.id=t2.id start with t1.id=1 CONNECT BY PRIOR t1.id = t1.pid;
 id | vch | pid | name | ptex 
----+-----+-----+------+------
(0 rows)

explain (costs off) select t1.ID,t1.VCH,pid,NAME,PTEX from TEST_HCB_FQB t1,TEST_SUBLINK t2 where t1.id=t2.id start with t1.id=1 CONNECT BY PRIOR t1.id = t1.pid;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 CTE Scan on tmp_reuslt
   CTE tmp_reuslt
     ->  StartWith Operator
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union
                 ->  Nested Loop
                       ->  Seq Scan on test_hcb_fqb t1
                             Filter: (id = 1)
                       ->  Seq Scan on test_sublink t2
                             Filter: (id = 1)
                 ->  Hash Join
                       Hash Cond: (t2.id = t1.id)
                       ->  Seq Scan on test_sublink t2
                       ->  Hash
                             ->  Hash Join
                                   Hash Cond: (tmp_reuslt."t1@id" = t1.pid)
                                   ->  WorkTable Scan on tmp_reuslt
                                   ->  Hash
                                         ->  Seq Scan on test_hcb_fqb t1
(19 rows)

/* swcb中参数为proceder参数 */
CREATE OR REPLACE FUNCTION test_hcb_pro1(i_id in int) return int
AS
o_out int;
BEGIN
select count(*) into o_out from TEST_HCB_FQB t1 START WITH t1.id = i_id
CONNECT BY PRIOR t1.id = t1.pid;
return o_out;
END;
/
select test_hcb_pro1(11);
 test_hcb_pro1 
---------------
            28
(1 row)

drop PROCEDURE test_hcb_pro1;
/* startwith dealing with subqueries */
select tt.id,tt.name from (select t1.ID,t1.VCH,pid,NAME,PTEX from TEST_HCB_FQB t1,TEST_SUBLINK t2 where t1.id=t2.id) tt
start with tt.id=1 CONNECT BY PRIOR tt.id = tt.pid ;
 id | name 
----+------
(0 rows)

explain (costs off) select tt.id,tt.name from (select t1.ID,t1.VCH,pid,NAME,PTEX from TEST_HCB_FQB t1,TEST_SUBLINK t2 where t1.id=t2.id) tt
start with tt.id=1 CONNECT BY PRIOR tt.id = tt.pid ;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 CTE Scan on tmp_reuslt
   CTE tmp_reuslt
     ->  StartWith Operator
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union
                 ->  Nested Loop
                       ->  Seq Scan on test_hcb_fqb t1
                             Filter: (id = 1)
                       ->  Seq Scan on test_sublink t2
                             Filter: (id = 1)
                 ->  Hash Join
                       Hash Cond: (t2.id = t1.id)
                       ->  Seq Scan on test_sublink t2
                       ->  Hash
                             ->  Hash Join
                                   Hash Cond: (tmp_reuslt."tt@id" = t1.pid)
                                   ->  WorkTable Scan on tmp_reuslt
                                   ->  Hash
                                         ->  Seq Scan on test_hcb_fqb t1
(19 rows)

select test.id,test.pid,test.name
from
(select t1.id id, t1.pid pid, t1.name name from TEST_HCB_FQB t1
 union
 select t2.id id, t2.pid pid, t2.name name from TEST_HCB_FQB t2) test
start with test.id = 12
connect by prior test.id = test.pid;
 id | pid |  name  
----+-----+--------
 12 |   1 | 山东省
(1 row)

/* startwith dealing with subqueries without alias  */
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,CONNECT_BY_ROOT(NAME),SYS_CONNECT_BY_PATH(NAME, '/')
FROM (SELECT * FROM test_hcb_ptb)
START WITH CHA IN ('afi','afg','afh')
CONNECT BY PRIOR ID=PID
ORDER SIBLINGS BY NAME;
   name   | level | connect_by_isleaf | connect_by_root | sys_connect_by_path 
----------+-------+-------------------+-----------------+---------------------
 第七单元 |     1 |                 1 | 第七单元        | /第七单元
 第九单元 |     1 |                 1 | 第九单元        | /第九单元
 第八单元 |     1 |                 1 | 第八单元        | /第八单元
(3 rows)

SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,CONNECT_BY_ROOT(NAME),SYS_CONNECT_BY_PATH(NAME, '/')
FROM (SELECT * FROM test_hcb_ptb)
START WITH CHA IN ('afi','afg','afh')
CONNECT BY PRIOR ID=PID
ORDER SIBLINGS BY 1;
   name   | level | connect_by_isleaf | connect_by_root | sys_connect_by_path 
----------+-------+-------------------+-----------------+---------------------
 第七单元 |     1 |                 1 | 第七单元        | /第七单元
 第九单元 |     1 |                 1 | 第九单元        | /第九单元
 第八单元 |     1 |                 1 | 第八单元        | /第八单元
(3 rows)

SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,CONNECT_BY_ROOT(NAME),SYS_CONNECT_BY_PATH(NAME, '/')
FROM (SELECT * FROM test_hcb_ptb)
START WITH CHA IN ('afi','afg','afh')
CONNECT BY PRIOR ID=PID
ORDER SIBLINGS BY 999;
ERROR:  Order siblings by tlistIdx 999 exceed length of targetList.
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,CONNECT_BY_ROOT(NAME),SYS_CONNECT_BY_PATH(NAME, '/')
FROM (SELECT * FROM test_hcb_ptb)
START WITH CHA IN ('afi','afg','afh')
CONNECT BY PRIOR ID=PID
ORDER SIBLINGS BY 1, LEVEL;
ERROR:  Siblings sort entry not found
DETAIL:  Column level not found or not allowed here
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,CONNECT_BY_ROOT(NAME),SYS_CONNECT_BY_PATH(NAME, '/')
FROM (SELECT * FROM test_hcb_ptb)
START WITH CHA IN ('afi','afg','afh')
CONNECT BY PRIOR ID=PID
ORDER SIBLINGS BY 1, HUAWEI;
ERROR:  Siblings sort entry not found
DETAIL:  Column huawei not found or not allowed here
/* check siblings ordering */
SELECT NAME,LEVEL,CONNECT_BY_ISLEAF,SYS_CONNECT_BY_PATH(NAME,'|'),CONNECT_BY_ROOT(NAME)
FROM test_hcb_ptb
START WITH (ID=168 or ID=169)
CONNECT BY ID = PRIOR PID
ORDER SIBLINGS BY NAME ASC;
   name   | level | connect_by_isleaf |                     sys_connect_by_path                      | connect_by_root 
----------+-------+-------------------+--------------------------------------------------------------+-----------------
 第九单元 |     1 |                 0 | |第九单元                                                    | 第九单元
 江南一楼 |     2 |                 0 | |第九单元|江南一楼                                           | 第九单元
 江南摩卡 |     3 |                 0 | |第九单元|江南一楼|江南摩卡                                  | 第九单元
 东山街   |     4 |                 0 | |第九单元|江南一楼|江南摩卡|东山街                           | 第九单元
 江宁区   |     5 |                 0 | |第九单元|江南一楼|江南摩卡|东山街|江宁区                    | 第九单元
 南京市   |     6 |                 0 | |第九单元|江南一楼|江南摩卡|东山街|江宁区|南京市             | 第九单元
 江苏省   |     7 |                 0 | |第九单元|江南一楼|江南摩卡|东山街|江宁区|南京市|江苏省      | 第九单元
 中国     |     8 |                 1 | |第九单元|江南一楼|江南摩卡|东山街|江宁区|南京市|江苏省|中国 | 第九单元
 第八单元 |     1 |                 0 | |第八单元                                                    | 第八单元
 江南一楼 |     2 |                 0 | |第八单元|江南一楼                                           | 第八单元
 江南摩卡 |     3 |                 0 | |第八单元|江南一楼|江南摩卡                                  | 第八单元
 东山街   |     4 |                 0 | |第八单元|江南一楼|江南摩卡|东山街                           | 第八单元
 江宁区   |     5 |                 0 | |第八单元|江南一楼|江南摩卡|东山街|江宁区                    | 第八单元
 南京市   |     6 |                 0 | |第八单元|江南一楼|江南摩卡|东山街|江宁区|南京市             | 第八单元
 江苏省   |     7 |                 0 | |第八单元|江南一楼|江南摩卡|东山街|江宁区|南京市|江苏省      | 第八单元
 中国     |     8 |                 1 | |第八单元|江南一楼|江南摩卡|东山街|江宁区|南京市|江苏省|中国 | 第八单元
(16 rows)

-- connect_by_root/sys_connect_by_path() unsupported cases
explain
SELECT *, LEVEL, connect_by_isleaf, connect_by_iscycle, connect_by_root name_desc, sys_connect_by_path(level, '@')
FROM test_area
START WITH name = '中国'
CONNECT BY PRIOR id = fatherid;
ERROR:  only base table column can be specified in connect_by_root/sys_connect_by_path()
-- sys_connect_by_path() only supports char type
explain
SELECT *, LEVEL, connect_by_isleaf, connect_by_iscycle, connect_by_root name_desc, sys_connect_by_path(id, '@')
FROM test_area
START WITH name = '中国'
CONNECT BY PRIOR id = fatherid;
ERROR:  only text type(CHAR/VARCHAR/NVARCHAR2/TEXT) is allow for sys_connect_by_path()
/* sys_connect_by_path & connect_by_root can support char(xx) */
SELECT name,LEVEL,connect_by_root(CHA)
FROM test_hcb_fqb
START WITH ID = 1
CONNECT BY PRIOR CHA = PCHA
ORDER BY ID ASC;
  name  | level | connect_by_root 
--------+-------+-----------------
 中国   |     1 | a         
 江苏省 |     2 | a         
 山东省 |     2 | a         
 安徽省 |     2 | a         
 河南省 |     2 | a         
 河北省 |     2 | a         
 湖南省 |     2 | a         
 湖北省 |     2 | a         
 贵州省 |     2 | a         
 武汉省 |     2 | a         
 南京市 |     3 | a         
 宿迁市 |     3 | a         
 徐州市 |     3 | a         
 苏州市 |     3 | a         
 盐城市 |     3 | a         
 无锡市 |     3 | a         
 常州市 |     3 | a         
 连云港 |     3 | a         
 泰州市 |     3 | a         
 江宁区 |     4 | a         
 雨花台 |     4 | a         
 鼓楼区 |     4 | a         
 玄武区 |     4 | a         
 建邺区 |     4 | a         
 秦淮区 |     4 | a         
 浦口区 |     4 | a         
 浦口区 |     4 | a         
 六合区 |     4 | a         
 东山街 |     5 | a         
 秣陵街 |     5 | a         
 汤山街 |     5 | a         
 淳化街 |     5 | a         
 禄口街 |     5 | a         
 江宁街 |     5 | a         
 谷里街 |     5 | a         
 湖熟街 |     5 | a         
 横溪街 |     5 | a         
(37 rows)

SELECT name,level,connect_by_root t1.cha as cha_col
FROM test_hcb_fqb t1
START WITH id = 1
CONNECT BY PRIOR cha = pcha
ORDER BY id ASC;
  name  | level |  cha_col   
--------+-------+------------
 中国   |     1 | a         
 江苏省 |     2 | a         
 山东省 |     2 | a         
 安徽省 |     2 | a         
 河南省 |     2 | a         
 河北省 |     2 | a         
 湖南省 |     2 | a         
 湖北省 |     2 | a         
 贵州省 |     2 | a         
 武汉省 |     2 | a         
 南京市 |     3 | a         
 宿迁市 |     3 | a         
 徐州市 |     3 | a         
 苏州市 |     3 | a         
 盐城市 |     3 | a         
 无锡市 |     3 | a         
 常州市 |     3 | a         
 连云港 |     3 | a         
 泰州市 |     3 | a         
 江宁区 |     4 | a         
 雨花台 |     4 | a         
 鼓楼区 |     4 | a         
 玄武区 |     4 | a         
 建邺区 |     4 | a         
 秦淮区 |     4 | a         
 浦口区 |     4 | a         
 浦口区 |     4 | a         
 六合区 |     4 | a         
 东山街 |     5 | a         
 秣陵街 |     5 | a         
 汤山街 |     5 | a         
 淳化街 |     5 | a         
 禄口街 |     5 | a         
 江宁街 |     5 | a         
 谷里街 |     5 | a         
 湖熟街 |     5 | a         
 横溪街 |     5 | a         
(37 rows)

SELECT name,LEVEL,sys_connect_by_path(CHA, '==》')
FROM test_hcb_fqb
START WITH ID = 1
CONNECT BY PRIOR CHA = PCHA
ORDER BY ID ASC;
  name  | level |                        sys_connect_by_path                        
--------+-------+-------------------------------------------------------------------
 中国   |     1 | ==》a         
 江苏省 |     2 | ==》a         ==》aa        
 山东省 |     2 | ==》a         ==》ab        
 安徽省 |     2 | ==》a         ==》ac        
 河南省 |     2 | ==》a         ==》ad        
 河北省 |     2 | ==》a         ==》ae        
 湖南省 |     2 | ==》a         ==》af        
 湖北省 |     2 | ==》a         ==》ag        
 贵州省 |     2 | ==》a         ==》ah        
 武汉省 |     2 | ==》a         ==》ai        
 南京市 |     3 | ==》a         ==》aa        ==》aaa       
 宿迁市 |     3 | ==》a         ==》aa        ==》aab       
 徐州市 |     3 | ==》a         ==》aa        ==》aac       
 苏州市 |     3 | ==》a         ==》aa        ==》aad       
 盐城市 |     3 | ==》a         ==》aa        ==》aae       
 无锡市 |     3 | ==》a         ==》aa        ==》aaf       
 常州市 |     3 | ==》a         ==》aa        ==》aag       
 连云港 |     3 | ==》a         ==》aa        ==》aah       
 泰州市 |     3 | ==》a         ==》aa        ==》aai       
 江宁区 |     4 | ==》a         ==》aa        ==》aaa       ==》aba       
 雨花台 |     4 | ==》a         ==》aa        ==》aaa       ==》abb       
 鼓楼区 |     4 | ==》a         ==》aa        ==》aaa       ==》abc       
 玄武区 |     4 | ==》a         ==》aa        ==》aaa       ==》abd       
 建邺区 |     4 | ==》a         ==》aa        ==》aaa       ==》abe       
 秦淮区 |     4 | ==》a         ==》aa        ==》aaa       ==》abf       
 浦口区 |     4 | ==》a         ==》aa        ==》aaa       ==》abg       
 浦口区 |     4 | ==》a         ==》aa        ==》aaa       ==》abh       
 六合区 |     4 | ==》a         ==》aa        ==》aaa       ==》abi       
 东山街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》aca       
 秣陵街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》acb       
 汤山街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》acc       
 淳化街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》acd       
 禄口街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》ace       
 江宁街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》acf       
 谷里街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》acg       
 湖熟街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》ach       
 横溪街 |     5 | ==》a         ==》aa        ==》aaa       ==》aba       ==》aci       
(37 rows)

/* empty delimiter in sys_connect_by_path(VCH,'') should be rejected */
SELECT name,LEVEL,sys_connect_by_path(VCH,'')
FROM test_hcb_ptb
START WITH ID = 1
CONNECT BY PRIOR CHA = PCHA
ORDER BY ID ASC;
ERROR:  illegal parameter in SYS_CONNECT_BY_PATH function
CONTEXT:  referenced column: sys_connect_by_path
/* start with null must not cause core-dump error */
SELECT *
FROM test_hcb_ptb
START WITH NULL
CONNECT BY PRIOR CHA = PCHA
ORDER BY ID ASC;
 id | cha | vch | tex | dat | tim | tis | name | pid | pcha | pvch | ptex | pdat | ptim | ptis 
----+-----+-----+-----+-----+-----+-----+------+-----+------+------+------+------+------+------
(0 rows)

/* start with pbe */
PREPARE sthpt(int) AS SELECT t1.id,t1.pid,t1.name FROM test_hcb_ptb t1 START WITH id = $1 CONNECT BY PRIOR pid=id;
EXECUTE sthpt(141);
 id  | pid |   name   
-----+-----+----------
 141 | 131 | 江南摩卡
 131 | 121 | 东山街
 121 | 111 | 江宁区
 111 |  11 | 南京市
  11 |   1 | 江苏省
   1 |   0 | 中国
(6 rows)

/* with-clause used in startwith rewrite */
explain (costs off) with subquery (id,pid,name) as
(
select t1.id,t1.pid,t1.name, LEVEL from test_hcb_ptb t1 where level>=1
    start with id = 141 connect by prior pid=id
)
select t1.id,t1.pid,t1.name,LEVEL from subquery t1
start with id = 141 connect by prior pid=id;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt
   CTE tmp_reuslt
     ->  StartWith Operator
           Start With pseudo atts: RUITR, array_key_2
           ->  Recursive Union
                 ->  CTE Scan on tmp_reuslt
                       Filter: ((level >= 1) AND ("t1@id" = 141))
                       CTE tmp_reuslt
                         ->  StartWith Operator
                               Start With pseudo atts: RUITR, array_key_9
                               ->  Recursive Union
                                     ->  Seq Scan on test_hcb_ptb t1
                                           Filter: (id = 141)
                                     ->  Hash Join
                                           Hash Cond: (t1.id = tmp_reuslt."t1@pid")
                                           ->  Seq Scan on test_hcb_ptb t1
                                           ->  Hash
                                                 ->  WorkTable Scan on tmp_reuslt
                 ->  Hash Join
                       Hash Cond: (tmp_reuslt."t1@id" = tmp_reuslt."t1@pid")
                       ->  Materialize
                             ->  CTE Scan on tmp_reuslt
                                   Filter: (level >= 1)
                                   CTE tmp_reuslt
                                     ->  StartWith Operator
                                           Start With pseudo atts: RUITR, array_key_9
                                           ->  Recursive Union
                                                 ->  Seq Scan on test_hcb_ptb t1
                                                       Filter: (id = 141)
                                                 ->  Hash Join
                                                       Hash Cond: (t1.id = tmp_reuslt."t1@pid")
                                                       ->  Seq Scan on test_hcb_ptb t1
                                                       ->  Hash
                                                             ->  WorkTable Scan on tmp_reuslt
                       ->  Hash
                             ->  WorkTable Scan on tmp_reuslt
(36 rows)

explain (costs off) select t1.id,t1.pid,t1.name,LEVEL
from (select t2.id,t2.pid,t2.name,LEVEL from test_hcb_ptb t2 where level>=1 start with t2.id = 141 connect by prior pid=id) t1
where level>=1 start with id = 141 connect by prior pid=id;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt
   Filter: (level >= 1)
   CTE tmp_reuslt
     ->  StartWith Operator
           Start With pseudo atts: RUITR, array_key_2
           ->  Recursive Union
                 ->  CTE Scan on tmp_reuslt
                       Filter: ((level >= 1) AND ("t2@id" = 141))
                       CTE tmp_reuslt
                         ->  StartWith Operator
                               Start With pseudo atts: RUITR, array_key_9
                               ->  Recursive Union
                                     ->  Seq Scan on test_hcb_ptb t2
                                           Filter: (id = 141)
                                     ->  Hash Join
                                           Hash Cond: (t2.id = tmp_reuslt."t2@pid")
                                           ->  Seq Scan on test_hcb_ptb t2
                                           ->  Hash
                                                 ->  WorkTable Scan on tmp_reuslt
                 ->  Hash Join
                       Hash Cond: (tmp_reuslt."t2@id" = tmp_reuslt."t1@pid")
                       ->  Materialize
                             ->  CTE Scan on tmp_reuslt
                                   Filter: (level >= 1)
                                   CTE tmp_reuslt
                                     ->  StartWith Operator
                                           Start With pseudo atts: RUITR, array_key_9
                                           ->  Recursive Union
                                                 ->  Seq Scan on test_hcb_ptb t2
                                                       Filter: (id = 141)
                                                 ->  Hash Join
                                                       Hash Cond: (t2.id = tmp_reuslt."t2@pid")
                                                       ->  Seq Scan on test_hcb_ptb t2
                                                       ->  Hash
                                                             ->  WorkTable Scan on tmp_reuslt
                       ->  Hash
                             ->  WorkTable Scan on tmp_reuslt
(37 rows)

/* core issue */
explain select sysdate from test_hcb_ptb t1 start with id = 141 connect by prior pid=id;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=37.11..39.89 rows=101 width=0)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..37.11 rows=101 width=102)
           Start With pseudo atts: RUITR, array_key_9
           ->  Recursive Union  (cost=0.00..37.11 rows=101 width=102)
                 ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.80 rows=1 width=102)
                       Filter: (id = 141)
                 ->  Hash Join  (cost=0.33..3.23 rows=10 width=102)
                       Hash Cond: (t1.id = tmp_reuslt."t1@pid")
                       ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.64 rows=64 width=102)
                       ->  Hash  (cost=0.20..0.20 rows=10 width=4)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
(12 rows)

select count(sysdate) from test_hcb_ptb t1 start with id = 141 connect by prior pid=id;
 count 
-------
     6
(1 row)

/* core issue sys_connect_by_path(cosnt) core issue */
select t1.id,t1.pid,LEVEL,sys_connect_by_path(null, '->') pa, t1.name from test_hcb_ptb t1 start with id = 141 connect by prior id = pid;
 id  | pid | level |         pa         |   name   
-----+-----+-------+--------------------+----------
 141 | 131 |     1 | ->null             | 江南摩卡
 151 | 141 |     2 | ->null->null       | 江南一楼
 152 | 141 |     2 | ->null->null       | 江南二楼
 153 | 141 |     2 | ->null->null       | 江南三楼
 154 | 141 |     2 | ->null->null       | 江南四楼
 155 | 141 |     2 | ->null->null       | 江南五楼
 156 | 141 |     2 | ->null->null       | 江南六楼
 157 | 141 |     2 | ->null->null       | 江南七楼
 158 | 141 |     2 | ->null->null       | 江南八楼
 159 | 141 |     2 | ->null->null       | 江南九楼
 161 | 151 |     3 | ->null->null->null | 第一单元
 162 | 151 |     3 | ->null->null->null | 第二单元
 163 | 151 |     3 | ->null->null->null | 第三单元
 164 | 151 |     3 | ->null->null->null | 第四单元
 165 | 151 |     3 | ->null->null->null | 第五单元
 166 | 151 |     3 | ->null->null->null | 第六单元
 167 | 151 |     3 | ->null->null->null | 第七单元
 168 | 151 |     3 | ->null->null->null | 第八单元
 169 | 151 |     3 | ->null->null->null | 第九单元
(19 rows)

select t1.id,t1.pid,LEVEL,sys_connect_by_path('id', '->') pa, t1.name from test_hcb_ptb t1 start with id = 141 connect by prior id = pid;
 id  | pid | level |      pa      |   name   
-----+-----+-------+--------------+----------
 141 | 131 |     1 | ->id         | 江南摩卡
 151 | 141 |     2 | ->id->id     | 江南一楼
 152 | 141 |     2 | ->id->id     | 江南二楼
 153 | 141 |     2 | ->id->id     | 江南三楼
 154 | 141 |     2 | ->id->id     | 江南四楼
 155 | 141 |     2 | ->id->id     | 江南五楼
 156 | 141 |     2 | ->id->id     | 江南六楼
 157 | 141 |     2 | ->id->id     | 江南七楼
 158 | 141 |     2 | ->id->id     | 江南八楼
 159 | 141 |     2 | ->id->id     | 江南九楼
 161 | 151 |     3 | ->id->id->id | 第一单元
 162 | 151 |     3 | ->id->id->id | 第二单元
 163 | 151 |     3 | ->id->id->id | 第三单元
 164 | 151 |     3 | ->id->id->id | 第四单元
 165 | 151 |     3 | ->id->id->id | 第五单元
 166 | 151 |     3 | ->id->id->id | 第六单元
 167 | 151 |     3 | ->id->id->id | 第七单元
 168 | 151 |     3 | ->id->id->id | 第八单元
 169 | 151 |     3 | ->id->id->id | 第九单元
(19 rows)

select t1.id,t1.pid,LEVEL,sys_connect_by_path(' ', '->') pa, t1.name from test_hcb_ptb t1 start with id = 141 connect by prior id = pid;
 id  | pid | level |    pa     |   name   
-----+-----+-------+-----------+----------
 141 | 131 |     1 | ->        | 江南摩卡
 151 | 141 |     2 | -> ->     | 江南一楼
 152 | 141 |     2 | -> ->     | 江南二楼
 153 | 141 |     2 | -> ->     | 江南三楼
 154 | 141 |     2 | -> ->     | 江南四楼
 155 | 141 |     2 | -> ->     | 江南五楼
 156 | 141 |     2 | -> ->     | 江南六楼
 157 | 141 |     2 | -> ->     | 江南七楼
 158 | 141 |     2 | -> ->     | 江南八楼
 159 | 141 |     2 | -> ->     | 江南九楼
 161 | 151 |     3 | -> -> ->  | 第一单元
 162 | 151 |     3 | -> -> ->  | 第二单元
 163 | 151 |     3 | -> -> ->  | 第三单元
 164 | 151 |     3 | -> -> ->  | 第四单元
 165 | 151 |     3 | -> -> ->  | 第五单元
 166 | 151 |     3 | -> -> ->  | 第六单元
 167 | 151 |     3 | -> -> ->  | 第七单元
 168 | 151 |     3 | -> -> ->  | 第八单元
 169 | 151 |     3 | -> -> ->  | 第九单元
(19 rows)

/* core issue, check args */
explain select t1.id,t1.pid,t1.name,level from test_hcb_ptb t1 start with id=141 connect by prior id=pid Order By NLSSORT ( id, ' NLS_SORT = SCHINESE_PINYIN_M ' );
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Sort  (cost=99.22..100.82 rows=641 width=190)
   Sort Key: (nlssort((tmp_reuslt."t1@id")::text, ' NLS_SORT = SCHINESE_PINYIN_M '::text))
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..53.31 rows=641 width=102)
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union  (cost=0.00..53.31 rows=641 width=102)
                 ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.80 rows=1 width=102)
                       Filter: (id = 141)
                 ->  Hash Join  (cost=0.33..3.77 rows=64 width=102)
                       Hash Cond: (t1.pid = tmp_reuslt."t1@id")
                       ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.64 rows=64 width=102)
                       ->  Hash  (cost=0.20..0.20 rows=10 width=4)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
   ->  CTE Scan on tmp_reuslt  (cost=0.00..16.02 rows=641 width=190)
(14 rows)

select t1.id,t1.pid,t1.name,level from test_hcb_ptb t1 start with id=141 connect by prior id=pid Order By NLSSORT ( id, ' NLS_SORT = SCHINESE_PINYIN_M ' );
 id  | pid |   name   | level 
-----+-----+----------+-------
 141 | 131 | 江南摩卡 |     1
 151 | 141 | 江南一楼 |     2
 152 | 141 | 江南二楼 |     2
 153 | 141 | 江南三楼 |     2
 154 | 141 | 江南四楼 |     2
 155 | 141 | 江南五楼 |     2
 156 | 141 | 江南六楼 |     2
 157 | 141 | 江南七楼 |     2
 158 | 141 | 江南八楼 |     2
 159 | 141 | 江南九楼 |     2
 161 | 151 | 第一单元 |     3
 162 | 151 | 第二单元 |     3
 163 | 151 | 第三单元 |     3
 164 | 151 | 第四单元 |     3
 165 | 151 | 第五单元 |     3
 166 | 151 | 第六单元 |     3
 167 | 151 | 第七单元 |     3
 168 | 151 | 第八单元 |     3
 169 | 151 | 第九单元 |     3
(19 rows)

/* core issue, check args */
drop table if exists region cascade;
create table region
(
    region_cd varchar(50) primary key ,
    REGION_MGR_ASSOCIATE_ID number(18,9),
    c1 serial
);
select region_mgr_associate_id from region;
 region_mgr_associate_id 
-------------------------
(0 rows)

drop table if exists item_price_history cascade;
create table item_price_history
(
    ITEM_ID number(39,10) primary key ,
    LOCATION_ID number(2,0) NULL,c1 serial
);
SELECT (MIN(region_cd)) Column_001, length(CAST('B' AS bytea), 'UTF8') Column_002
FROM region , item_price_history
WHERE REGION_MGR_ASSOCIATE_ID = ITEM_ID
START WITH REGION_MGR_ASSOCIATE_ID NOT LIKE '_W_'
CONNECT BY PRIOR LOCATION_ID = REGION_MGR_ASSOCIATE_ID
GROUP BY 2;
 column_001 | column_002 
------------+------------
(0 rows)

drop table item_price_history;
drop table region;
/*  */
create table test1(id int,pid int,name text, level int);
create table test2(id int,pid int,name text, connect_by_iscycle int);
create table test3(id int,pid int,name text, connect_by_isleaf int);
create table test4(id int,pid int,name text, c4 int);
insert into test1 select id,pid,name,id%10 from test_hcb_ptb;
insert into test2 select id,pid,name,id%10 from test_hcb_ptb;
insert into test3 select id,pid,name,id%10 from test_hcb_ptb;
insert into test4 select id,pid,name,id%10 from test_hcb_ptb;
/* level/connect_by_iscycle/connect_by_isleaf is for connect by's level value */
select id,pid,name,test1.level, level from test1 start with id = 141 connect by prior pid=id;
 id  | pid |   name   | level | level 
-----+-----+----------+-------+-------
 141 | 131 | 江南摩卡 |     1 |     1
 131 | 121 | 东山街   |     1 |     2
 121 | 111 | 江宁区   |     1 |     3
 111 |  11 | 南京市   |     1 |     4
  11 |   1 | 江苏省   |     1 |     5
   1 |   0 | 中国     |     1 |     6
(6 rows)

select id,pid,name,test2.connect_by_iscycle, connect_by_iscycle from test2 start with id = 141 connect by prior pid=id;
 id  | pid |   name   | connect_by_iscycle | connect_by_iscycle 
-----+-----+----------+--------------------+--------------------
 141 | 131 | 江南摩卡 |                  1 |                  0
 131 | 121 | 东山街   |                  1 |                  0
 121 | 111 | 江宁区   |                  1 |                  0
 111 |  11 | 南京市   |                  1 |                  0
  11 |   1 | 江苏省   |                  1 |                  0
   1 |   0 | 中国     |                  1 |                  0
(6 rows)

select id,pid,name,test3.connect_by_isleaf, connect_by_isleaf from test3 start with id = 141 connect by prior pid=id;
 id  | pid |   name   | connect_by_isleaf | connect_by_isleaf 
-----+-----+----------+-------------------+-------------------
 141 | 131 | 江南摩卡 |                 1 |                 0
 131 | 121 | 东山街   |                 1 |                 0
 121 | 111 | 江宁区   |                 1 |                 0
 111 |  11 | 南京市   |                 1 |                 0
  11 |   1 | 江苏省   |                 1 |                 0
   1 |   0 | 中国     |                 1 |                 1
(6 rows)

drop table test1;
drop table test2;
drop table test3;
drop table test4;
/* */
/* 查询1 */
SELECT TRAIT_VALUE_CD
FROM trait_value
START WITH TRAIT_VALUE_CD=TRAIT_VALUE_CD
CONNECT BY PRIOR UOM_CD LIKE '_E_';
 trait_value_cd 
----------------
 A
 B
 C
 D
 E
 F
(6 rows)

create table region
(
    region_cd varchar(50) primary key ,
    REGION_MGR_ASSOCIATE_ID number(18,9),c1 serial
);
create table item_price_history
(
    ITEM_ID number(39,10) primary key ,
    LOCATION_ID number(2,0) NULL,c1 serial
);
INSERT INTO REGION VALUES ('A', 0.123433);
INSERT INTO REGION VALUES ('B', NULL);
INSERT INTO REGION VALUES ('C', 2.232008908);
INSERT INTO REGION VALUES ('D', 3.878789);
INSERT INTO REGION VALUES ('E', 4.89060603);
INSERT INTO REGION VALUES ('F', 5.82703827);
INSERT INTO REGION VALUES ('G', NULL);
INSERT INTO REGION VALUES ('H', 7.3829083);
INSERT INTO ITEM_PRICE_HISTORY VALUES (0.12, 4);
INSERT INTO ITEM_PRICE_HISTORY VALUES (1.3, 1);
INSERT INTO ITEM_PRICE_HISTORY VALUES (2.23, NULL);
INSERT INTO ITEM_PRICE_HISTORY VALUES (3.33, 3);
INSERT INTO ITEM_PRICE_HISTORY VALUES (4.98, 4);
INSERT INTO ITEM_PRICE_HISTORY VALUES (5.01, 5);
INSERT INTO ITEM_PRICE_HISTORY VALUES (6, 6);
INSERT INTO ITEM_PRICE_HISTORY VALUES (0.7, 7);
INSERT INTO ITEM_PRICE_HISTORY VALUES (0.08, 8);
INSERT INTO ITEM_PRICE_HISTORY VALUES (9.12, 9);
/* 查询2 */
SELECT 1
FROM region , item_price_history
WHERE REGION_MGR_ASSOCIATE_ID = ITEM_ID
START WITH REGION_MGR_ASSOCIATE_ID NOT LIKE '_W_'
CONNECT BY PRIOR LOCATION_ID = REGION_MGR_ASSOCIATE_ID;
 ?column? 
----------
(0 rows)

drop table region;
drop table item_price_history;
/*  */
create table test1(c1 int, c2 int, c3 int);
insert into test1 values(1,1,1);
insert into test1 values(2,2,2);
-- encountered with 200 iteration limit
select * from test1 t1 start with c1=1 connect by prior c2<>c3;
ERROR:  START WITH .. CONNECT BY statement runs into cycle exception
-- will return result when cycle is met
select * from test1 t1 start with c1=1 connect by NOCYCLE prior c2<>c3;
 c1 | c2 | c3 
----+----+----
  1 |  1 |  1
  2 |  2 |  2
(2 rows)

drop table test1;
-- error out a case when NOCYCLE is not specify and use connect_by_iscycle
select t1.id, LEVEL, connect_by_iscycle from test_hcb_ptb t1 start with id = 1 connect by  prior id = pid;
 id  | level | connect_by_iscycle 
-----+-------+--------------------
   1 |     1 |                  0
  11 |     2 |                  0
  12 |     2 |                  0
  13 |     2 |                  0
  14 |     2 |                  0
  15 |     2 |                  0
  16 |     2 |                  0
  17 |     2 |                  0
  18 |     2 |                  0
  19 |     2 |                  0
 111 |     3 |                  0
 112 |     3 |                  0
 113 |     3 |                  0
 114 |     3 |                  0
 115 |     3 |                  0
 117 |     3 |                  0
 116 |     3 |                  0
 118 |     3 |                  0
 119 |     3 |                  0
 121 |     4 |                  0
 122 |     4 |                  0
 123 |     4 |                  0
 124 |     4 |                  0
 125 |     4 |                  0
 126 |     4 |                  0
 127 |     4 |                  0
 128 |     4 |                  0
 129 |     4 |                  0
 131 |     5 |                  0
 132 |     5 |                  0
 133 |     5 |                  0
 135 |     5 |                  0
 134 |     5 |                  0
 136 |     5 |                  0
 137 |     5 |                  0
 138 |     5 |                  0
 139 |     5 |                  0
 141 |     6 |                  0
 142 |     6 |                  0
 143 |     6 |                  0
 144 |     6 |                  0
 145 |     6 |                  0
 146 |     6 |                  0
 147 |     6 |                  0
 148 |     6 |                  0
 149 |     6 |                  0
 151 |     7 |                  0
 152 |     7 |                  0
 153 |     7 |                  0
 154 |     7 |                  0
 155 |     7 |                  0
 156 |     7 |                  0
 157 |     7 |                  0
 158 |     7 |                  0
 159 |     7 |                  0
 161 |     8 |                  0
 162 |     8 |                  0
 163 |     8 |                  0
 164 |     8 |                  0
 165 |     8 |                  0
 166 |     8 |                  0
 167 |     8 |                  0
 168 |     8 |                  0
 169 |     8 |                  0
(64 rows)

create table mag_area
(
    area_code varchar(10),
    area_name varchar(120),
    area_short_name  varchar(120),
    local_name      varchar(80),
    belong_area_code    varchar(10),
    bank_level      varchar(8),
    contry_code     varchar(5),
    part_code       varchar(5),
    time_zone       varchar(9),
    bank_code           varchar(10),
    group_code          varchar(5),
    mag_area_grade      varchar(3),
    mag_area_status     varchar(1),
    mag_area_broad      varchar(1)
);
create table mag_image_tpl
(
    seq         varchar(20),
    area_code   varchar(10),
    archive_type varchar(3),
    busitype     varchar(8),
    image_type   varchar(8),
    app_type     varchar(10),
    rule_id      varchar(10),
    valid_flag   varchar(1),
    modify_branch varchar(10),
    modify_user   varchar(9),
    modify_time   varchar(14)
);
explain
select a.rule_id, b.mag_area_grade,
       max(b.mag_area_grade) OVER (PARTITION BY archive_type, busitype,image_type,app_type) max_level
FROM  mag_image_tpl a, mag_area b
WHERE a.AREA_CODE IN (
    SELECT area_code
    FROM mag_area
    START WITH area_code = '1'
    CONNECT BY PRIOR belong_area_code = area_code
)
AND a.archive_type = 'A'
AND a.BUSITYPE = 'B'
AND a.area_code = b.area_code;
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 WindowAgg  (cost=156.54..156.56 rows=1 width=176)
   ->  Sort  (cost=156.54..156.54 rows=1 width=176)
         Sort Key: a.image_type, a.app_type
         ->  Nested Loop Semi Join  (cost=127.46..156.53 rows=1 width=176)
               Join Filter: ((a.area_code)::text = (tmp_reuslt."mag_area@area_code")::text)
               ->  Nested Loop  (cost=0.00..24.78 rows=1 width=252)
                     Join Filter: ((a.area_code)::text = (b.area_code)::text)
                     ->  Seq Scan on mag_image_tpl a  (cost=0.00..12.96 rows=1 width=198)
                           Filter: (((archive_type)::text = 'A'::text) AND ((busitype)::text = 'B'::text))
                     ->  Seq Scan on mag_area b  (cost=0.00..10.81 rows=81 width=54)
               ->  CTE Scan on tmp_reuslt  (cost=127.46..129.48 rows=101 width=38)
                     CTE tmp_reuslt
                       ->  StartWith Operator  (cost=0.00..127.46 rows=101 width=982)
                             Start With pseudo atts: RUITR, array_key_5
                             ->  Recursive Union  (cost=0.00..127.46 rows=101 width=982)
                                   ->  Seq Scan on mag_area  (cost=0.00..11.01 rows=1 width=982)
                                         Filter: ((area_code)::text = '1'::text)
                                   ->  Hash Join  (cost=0.33..11.44 rows=10 width=982)
                                         Hash Cond: ((swtest.mag_area.area_code)::text = (tmp_reuslt."mag_area@belong_area_code")::text)
                                         ->  Seq Scan on mag_area  (cost=0.00..10.81 rows=81 width=982)
                                         ->  Hash  (cost=0.20..0.20 rows=10 width=38)
                                               ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=38)
(22 rows)

select a.rule_id, b.mag_area_grade,
       max(b.mag_area_grade) OVER (PARTITION BY archive_type, busitype,image_type,app_type) max_level
FROM  mag_image_tpl a, mag_area b
WHERE a.AREA_CODE IN (
    SELECT area_code
    FROM mag_area
    START WITH area_code = '1'
    CONNECT BY PRIOR belong_area_code = area_code
)
AND a.archive_type = 'A'
AND a.BUSITYPE = 'B'
AND a.area_code = b.area_code;
 rule_id | mag_area_grade | max_level 
---------+----------------+-----------
(0 rows)

drop table mag_area;
drop table mag_image_tpl;
SELECT id, sys_connect_by_path(name_desc, '@') || id
FROM test_area
START WITH name = '耒阳市'
CONNECT BY id = PRIOR fatherid;
 id |            ?column?            
----+--------------------------------
 14 | @Leiyang14
 13 | @Leiyang@Hengyang13
  2 | @Leiyang@Hengyang@Hunan2
  1 | @Leiyang@Hengyang@Hunan@China1
(4 rows)

explain
SELECT table_name || NVL('test','_B$') AS table_name
            FROM (SELECT TRIM(SUBSTR(txt,
                                INSTR(txt, ',', 1, LEVEL) + 1,
                                INSTR(txt, ',', 1, LEVEL + 1) -
                                INSTR(txt, ',', 1, LEVEL) - 1)) AS table_name
                  FROM (SELECT ',' || REPLACE('test' , ' ', '') || ',' txt FROM sys_dummy)
                  CONNECT BY LEVEL <= LENGTH(REPLACE('test', ' ', '')) - LENGTH(REPLACE(REPLACE('test', ' ', ''), ',', '')) + 1);
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Subquery Scan on __unnamed_subquery__  (cost=5.24..10.79 rows=101 width=32)
   ->  CTE Scan on tmp_reuslt  (cost=5.24..9.53 rows=101 width=36)
         CTE tmp_reuslt
           ->  StartWith Operator  (cost=0.00..5.24 rows=101 width=0)
                 Start With pseudo atts: RUITR
                 ->  Recursive Union  (cost=0.00..5.24 rows=101 width=0)
                       ->  Subquery Scan on sys_dummy  (cost=0.00..0.02 rows=1 width=0)
                             ->  Result  (cost=0.00..0.01 rows=1 width=0)
                       ->  Nested Loop  (cost=0.00..0.32 rows=10 width=0)
                             ->  Result  (cost=0.00..0.01 rows=1 width=0)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=0)
(11 rows)

SELECT table_name || NVL('test','_B$') AS table_name
            FROM (SELECT TRIM(SUBSTR(txt,
                                INSTR(txt, ',', 1, LEVEL) + 1,
                                INSTR(txt, ',', 1, LEVEL + 1) -
                                INSTR(txt, ',', 1, LEVEL) - 1)) AS table_name
                  FROM (SELECT ',' || REPLACE('test' , ' ', '') || ',' txt FROM sys_dummy)
                  CONNECT BY LEVEL <= LENGTH(REPLACE('test', ' ', '')) - LENGTH(REPLACE(REPLACE('test', ' ', ''), ',', '')) + 1);
 table_name 
------------
 testtest
(1 row)

-- fix infinite recursive
explain select * from t1 start with id = 1 connect by prior id != pid;
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=43.96..60.18 rows=811 width=40)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..43.96 rows=811 width=10)
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union  (cost=0.00..43.96 rows=811 width=10)
                 ->  Seq Scan on t1  (cost=0.00..1.11 rows=1 width=10)
                       Filter: (id = 1)
                 ->  Nested Loop  (cost=0.00..2.66 rows=81 width=10)
                       Join Filter: (tmp_reuslt."t1@id" <> swtest.t1.pid)
                       ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
                       ->  Materialize  (cost=0.00..1.14 rows=9 width=10)
                             ->  Seq Scan on t1  (cost=0.00..1.09 rows=9 width=10)
(12 rows)

create table tsc_rtbl(c_int int,c_varchar1 varchar,c_varchar2 varchar);
alter table tsc_rtbl drop column c_varchar2;
alter table tsc_rtbl add column c_varchar2 varchar;
select c_int,c_varchar1,c_varchar2 from tsc_rtbl
start with c_int<10 connect by nocycle prior c_int=c_int;
 c_int | c_varchar1 | c_varchar2 
-------+------------+------------
(0 rows)

create table t1_area (id int4,name text, fatherid int4, name_desc text);
insert into t1_area values (1, '中国',  0,  'China');
insert into t1_area values (2, '湖南省',1 , 'Hunan');
insert into t1_area values (3, '广东省',1 , 'Guangdong');
insert into t1_area values (4, '海南省',1 , 'Hainan');
insert into t1_area values (5, '河北省',1 , 'Hebei');
insert into t1_area values (6, '河南省',1 , 'Henan');
insert into t1_area values (7, '山东省',1 , 'Shandong');
insert into t1_area values (8, '湖北省',1 , 'Hubei');
insert into t1_area values (9, '江苏省',1 , 'Jiangsu');
insert into t1_area values (10,'深圳市',3 , 'Shenzhen');
insert into t1_area values (11,'长沙市',2 , 'Changsha');
insert into t1_area values (22,'祁北县',13, 'Qibei');
insert into t1_area values (12,'南山区',10, 'Nanshan');
insert into t1_area values (21,'祁西县',13, 'Qixi');
insert into t1_area values (13,'衡阳市',2 , 'Hengyang');
insert into t1_area values (14,'耒阳市',13, 'Leiyang');
insert into t1_area values (15,'龙岗区',10, 'Longgang');
insert into t1_area values (16,'福田区',10, 'Futian');
insert into t1_area values (17,'宝安区',10, 'Baoan');
insert into t1_area values (19,'祁东县',13, 'Qidong');
insert into t1_area values (18,'常宁市',13, 'Changning');
insert into t1_area values (20,'祁南县',13, 'Qinan');
SELECT *, connect_by_root(name_desc), sys_connect_by_path(name_desc, '->')
FROM t1_area
START WITH name = '耒阳市'
CONNECT BY id = PRIOR fatherid;
 id |  name  | fatherid | name_desc | connect_by_root |        sys_connect_by_path        
----+--------+----------+-----------+-----------------+-----------------------------------
 14 | 耒阳市 |       13 | Leiyang   | Leiyang         | ->Leiyang
 13 | 衡阳市 |        2 | Hengyang  | Leiyang         | ->Leiyang->Hengyang
  2 | 湖南省 |        1 | Hunan     | Leiyang         | ->Leiyang->Hengyang->Hunan
  1 | 中国   |        0 | China     | Leiyang         | ->Leiyang->Hengyang->Hunan->China
(4 rows)

--创建drop column并加回场景
alter table t1_area drop column name_desc;
alter table t1_area add column name_desc text;
-- 原有备drop列为空
SELECT *, connect_by_root(name_desc), sys_connect_by_path(name_desc, '->')
FROM t1_area
START WITH name = '耒阳市'
CONNECT BY id = PRIOR fatherid;
 id |  name  | fatherid | name_desc | connect_by_root |   sys_connect_by_path    
----+--------+----------+-----------+-----------------+--------------------------
 14 | 耒阳市 |       13 |           |                 | ->null
 13 | 衡阳市 |        2 |           |                 | ->null->null
  2 | 湖南省 |        1 |           |                 | ->null->null->null
  1 | 中国   |        0 |           |                 | ->null->null->null->null
(4 rows)

-- 新插入相同数据，原有drop列后的空值和当前有效值并存
insert into t1_area values (1, '中国',  0,  'China');
insert into t1_area values (2, '湖南省',1 , 'Hunan');
insert into t1_area values (3, '广东省',1 , 'Guangdong');
insert into t1_area values (4, '海南省',1 , 'Hainan');
insert into t1_area values (5, '河北省',1 , 'Hebei');
insert into t1_area values (6, '河南省',1 , 'Henan');
insert into t1_area values (7, '山东省',1 , 'Shandong');
insert into t1_area values (8, '湖北省',1 , 'Hubei');
insert into t1_area values (9, '江苏省',1 , 'Jiangsu');
insert into t1_area values (10,'深圳市',3 , 'Shenzhen');
insert into t1_area values (11,'长沙市',2 , 'Changsha');
insert into t1_area values (22,'祁北县',13, 'Qibei');
insert into t1_area values (12,'南山区',10, 'Nanshan');
insert into t1_area values (21,'祁西县',13, 'Qixi');
insert into t1_area values (13,'衡阳市',2 , 'Hengyang');
insert into t1_area values (14,'耒阳市',13, 'Leiyang');
insert into t1_area values (15,'龙岗区',10, 'Longgang');
insert into t1_area values (16,'福田区',10, 'Futian');
insert into t1_area values (17,'宝安区',10, 'Baoan');
insert into t1_area values (19,'祁东县',13, 'Qidong');
insert into t1_area values (18,'常宁市',13, 'Changning');
insert into t1_area values (20,'祁南县',13, 'Qinan');
SELECT *, connect_by_root(name_desc), sys_connect_by_path(name_desc, '->')
FROM t1_area
START WITH name = '耒阳市'
CONNECT BY id = PRIOR fatherid;
 id |  name  | fatherid | name_desc | connect_by_root |        sys_connect_by_path        
----+--------+----------+-----------+-----------------+-----------------------------------
 14 | 耒阳市 |       13 |           |                 | ->null
 14 | 耒阳市 |       13 | Leiyang   | Leiyang         | ->Leiyang
 13 | 衡阳市 |        2 |           |                 | ->Leiyang->null
 13 | 衡阳市 |        2 |           |                 | ->null->null
 13 | 衡阳市 |        2 | Hengyang  | Leiyang         | ->Leiyang->Hengyang
 13 | 衡阳市 |        2 | Hengyang  | null            | ->null->Hengyang
  2 | 湖南省 |        1 |           |                 | ->null->Hengyang->null
  2 | 湖南省 |        1 |           |                 | ->Leiyang->Hengyang->null
  2 | 湖南省 |        1 |           |                 | ->null->null->null
  2 | 湖南省 |        1 |           |                 | ->Leiyang->null->null
  2 | 湖南省 |        1 | Hunan     | null            | ->null->Hengyang->Hunan
  2 | 湖南省 |        1 | Hunan     | Leiyang         | ->Leiyang->Hengyang->Hunan
  2 | 湖南省 |        1 | Hunan     | null            | ->null->null->Hunan
  2 | 湖南省 |        1 | Hunan     | Leiyang         | ->Leiyang->null->Hunan
  1 | 中国   |        0 |           |                 | ->Leiyang->null->Hunan->null
  1 | 中国   |        0 |           |                 | ->null->null->Hunan->null
  1 | 中国   |        0 |           |                 | ->Leiyang->Hengyang->Hunan->null
  1 | 中国   |        0 |           |                 | ->null->Hengyang->Hunan->null
  1 | 中国   |        0 |           |                 | ->Leiyang->null->null->null
  1 | 中国   |        0 |           |                 | ->null->null->null->null
  1 | 中国   |        0 |           |                 | ->Leiyang->Hengyang->null->null
  1 | 中国   |        0 |           |                 | ->null->Hengyang->null->null
  1 | 中国   |        0 | China     | Leiyang         | ->Leiyang->null->Hunan->China
  1 | 中国   |        0 | China     | null            | ->null->null->Hunan->China
  1 | 中国   |        0 | China     | Leiyang         | ->Leiyang->Hengyang->Hunan->China
  1 | 中国   |        0 | China     | null            | ->null->Hengyang->Hunan->China
  1 | 中国   |        0 | China     | Leiyang         | ->Leiyang->null->null->China
  1 | 中国   |        0 | China     | null            | ->null->null->null->China
  1 | 中国   |        0 | China     | Leiyang         | ->Leiyang->Hengyang->null->China
  1 | 中国   |        0 | China     | null            | ->null->Hengyang->null->China
(30 rows)

SELECT * FROM t1_area START WITH id in ('1','2') CONNECT BY PRIOR fatherid = id;
 id |  name  | fatherid | name_desc 
----+--------+----------+-----------
  1 | 中国   |        0 | 
  2 | 湖南省 |        1 | 
  1 | 中国   |        0 | China
  2 | 湖南省 |        1 | Hunan
  1 | 中国   |        0 | 
  1 | 中国   |        0 | 
  1 | 中国   |        0 | China
  1 | 中国   |        0 | China
(8 rows)

SELECT * FROM t1_area START WITH (cast(id as varchar) COLLATE "C") in (cast(+ (id) as varchar) COLLATE "C")  and id < 4 connect by id = prior fatherid;
 id |  name  | fatherid | name_desc 
----+--------+----------+-----------
  1 | 中国   |        0 | 
  2 | 湖南省 |        1 | 
  3 | 广东省 |        1 | 
  1 | 中国   |        0 | China
  2 | 湖南省 |        1 | Hunan
  3 | 广东省 |        1 | Guangdong
  1 | 中国   |        0 | 
  1 | 中国   |        0 | 
  1 | 中国   |        0 | 
  1 | 中国   |        0 | 
  1 | 中国   |        0 | China
  1 | 中国   |        0 | China
  1 | 中国   |        0 | China
  1 | 中国   |        0 | China
(14 rows)

SELECT * FROM t1_area, tsc_rtbl START WITH id = 1 CONNECT BY PRIOR fatherid = id;
 id | name | fatherid | name_desc | c_int | c_varchar1 | c_varchar2 
----+------+----------+-----------+-------+------------+------------
(0 rows)

SELECT *, connect_by_root(name_desc), sys_connect_by_path(name_desc, '->')
FROM t1_area;
ERROR:  Invalid function call.
DETAIL:  START WITH CONNECT BY function found in non-hierarchical query.
CONTEXT:  referenced column: connect_by_root
/* fix start with in with clause */
explain (costs off) WITH WITH_001 AS (SELECT 1 FROM offers_20050701 ,trait_value START WITH PARTY_ID=TRAIT_VAL CONNECT BY PRIOR TRAIT_VALUE_CD LIKE '%V%')
SELECT mfg
FROM brand ,trait_value ,WITH_001
START WITH TRAIT_VALUE_CD=brand_name
CONNECT BY PRIOR brand_cd=UOM_CD;
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt
   CTE tmp_reuslt
     ->  StartWith Operator
           Start With pseudo atts: RUITR, array_key_3
           ->  Recursive Union
                 ->  Nested Loop
                       ->  CTE Scan on tmp_reuslt
                             CTE tmp_reuslt
                               ->  StartWith Operator
                                     Start With pseudo atts: RUITR, array_key_4
                                     ->  Recursive Union
                                           ->  Hash Join
                                                 Hash Cond: ((swtest.offers_20050701.party_id)::text = (swtest.trait_value.trait_val)::text)
                                                 ->  Seq Scan on offers_20050701
                                                 ->  Hash
                                                       ->  Seq Scan on trait_value
                                           ->  Nested Loop
                                                 ->  Nested Loop
                                                       ->  WorkTable Scan on tmp_reuslt
                                                             Filter: (("trait_value@trait_value_cd")::text ~~ '%V%'::text)
                                                       ->  Materialize
                                                             ->  Seq Scan on trait_value
                                                 ->  Materialize
                                                       ->  Seq Scan on offers_20050701
                       ->  Materialize
                             ->  Hash Join
                                   Hash Cond: ((swtest.brand.brand_name)::text = (swtest.trait_value.trait_value_cd)::text)
                                   ->  Seq Scan on brand
                                   ->  Hash
                                         ->  Seq Scan on trait_value
                 ->  Hash Join
                       Hash Cond: ((tmp_reuslt."brand@brand_cd")::text = (swtest.trait_value.uom_cd)::text)
                       ->  Nested Loop
                             ->  WorkTable Scan on tmp_reuslt
                             ->  Materialize
                                   ->  Seq Scan on brand
                       ->  Hash
                             ->  Nested Loop
                                   ->  CTE Scan on tmp_reuslt
                                         CTE tmp_reuslt
                                           ->  StartWith Operator
                                                 Start With pseudo atts: RUITR, array_key_4
                                                 ->  Recursive Union
                                                       ->  Hash Join
                                                             Hash Cond: ((swtest.offers_20050701.party_id)::text = (swtest.trait_value.trait_val)::text)
                                                             ->  Seq Scan on offers_20050701
                                                             ->  Hash
                                                                   ->  Seq Scan on trait_value
                                                       ->  Nested Loop
                                                             ->  Nested Loop
                                                                   ->  WorkTable Scan on tmp_reuslt
                                                                         Filter: (("trait_value@trait_value_cd")::text ~~ '%V%'::text)
                                                                   ->  Materialize
                                                                         ->  Seq Scan on trait_value
                                                             ->  Materialize
                                                                   ->  Seq Scan on offers_20050701
                                   ->  Materialize
                                         ->  Seq Scan on trait_value
(58 rows)

WITH WITH_001 AS (SELECT 1 FROM offers_20050701 ,trait_value START WITH PARTY_ID=TRAIT_VAL CONNECT BY PRIOR TRAIT_VALUE_CD LIKE '%V%')
SELECT mfg
FROM brand ,trait_value ,WITH_001
START WITH TRAIT_VALUE_CD=brand_name
CONNECT BY PRIOR brand_cd=UOM_CD;
 mfg 
-----
(0 rows)

/* fix reference to level in connect by function calls */
SELECT 1, level FROM t1_area CONNECT BY length(level) IS NULL;
 ?column? | level 
----------+-------
(0 rows)

/* prior params of procedure */
create or replace function test_tmp1(out id int,out pid int,out name varchar,out level int) return SETOF RECORD
IS
declare
CURSOR C1(sedid int) IS select t1.id,t1.pid,t1.name,level from test_hcb_ptb t1 start with id = sedid connect by prior pid=id;
begin
open C1(141);
loop
fetch C1 into id,pid,name,level;
EXIT WHEN C1%NOTFOUND;
return next;
end loop;
close C1;
end;
/
select * from test_tmp1();
 id  | pid |   name   | level 
-----+-----+----------+-------
 141 | 131 | 江南摩卡 |     1
 131 | 121 | 东山街   |     2
 121 | 111 | 江宁区   |     3
 111 |  11 | 南京市   |     4
  11 |   1 | 江苏省   |     5
   1 |   0 | 中国     |     6
(6 rows)

drop procedure test_tmp1;
drop table t1_area;
drop table tsc_rtbl;
-- 原问题单场景，connect_by_root(1)出现在在表达式中报错
explain
select t1.id,t1.pid,t1.name,LEVEL le,connect_by_root(1), connect_by_root(id)
from test_hcb_ptb t1
where connect_by_root(1) > 0
start with id = 141
connect by prior pid=id;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Result  (cost=37.12..39.89 rows=101 width=190)
   One-Time Filter: ((connect_by_root('1'::text))::bigint > 0)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..37.11 rows=101 width=102)
           Start With pseudo atts: RUITR, array_key_9, array_col_1
           ->  Recursive Union  (cost=0.00..37.11 rows=101 width=102)
                 ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.80 rows=1 width=102)
                       Filter: (id = 141)
                 ->  Hash Join  (cost=0.33..3.23 rows=10 width=102)
                       Hash Cond: (t1.id = tmp_reuslt."t1@pid")
                       ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.64 rows=64 width=102)
                       ->  Hash  (cost=0.20..0.20 rows=10 width=4)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
   ->  CTE Scan on tmp_reuslt  (cost=0.01..2.03 rows=101 width=190)
(14 rows)

select t1.id,t1.pid,t1.name,LEVEL le,connect_by_root(1), connect_by_root(id)
from test_hcb_ptb t1
where connect_by_root(1) > 0
start with id = 141
connect by prior pid=id;
 id  | pid |   name   | le | connect_by_root | connect_by_root 
-----+-----+----------+----+-----------------+-----------------
 141 | 131 | 江南摩卡 |  1 | 1               | 141
 131 | 121 | 东山街   |  2 | 1               | 141
 121 | 111 | 江宁区   |  3 | 1               | 141
 111 |  11 | 南京市   |  4 | 1               | 141
  11 |   1 | 江苏省   |  5 | 1               | 141
   1 |   0 | 中国     |  6 | 1               | 141
(6 rows)

-- 扩展场景, connect_by_root(id)报错找不到列
explain
select t1.id,t1.pid,t1.name,LEVEL le,connect_by_root(1), connect_by_root(id)
from test_hcb_ptb t1
where connect_by_root(id) > 0
start with id = 141
connect by prior pid=id;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=37.11..40.39 rows=34 width=190)
   Filter: ((connect_by_root(("t1@id")::text))::bigint > 0)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..37.11 rows=101 width=102)
           Start With pseudo atts: RUITR, array_key_9, array_col_1
           ->  Recursive Union  (cost=0.00..37.11 rows=101 width=102)
                 ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.80 rows=1 width=102)
                       Filter: (id = 141)
                 ->  Hash Join  (cost=0.33..3.23 rows=10 width=102)
                       Hash Cond: (t1.id = tmp_reuslt."t1@pid")
                       ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.64 rows=64 width=102)
                       ->  Hash  (cost=0.20..0.20 rows=10 width=4)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
(13 rows)

select t1.id,t1.pid,t1.name,LEVEL le,connect_by_root(1), connect_by_root(id)
from test_hcb_ptb t1
where connect_by_root(id) > 0
start with id = 141
connect by prior pid=id;
 id  | pid |   name   | le | connect_by_root | connect_by_root 
-----+-----+----------+----+-----------------+-----------------
 141 | 131 | 江南摩卡 |  1 | 1               | 141
 131 | 121 | 东山街   |  2 | 1               | 141
 121 | 111 | 江宁区   |  3 | 1               | 141
 111 |  11 | 南京市   |  4 | 1               | 141
  11 |   1 | 江苏省   |  5 | 1               | 141
   1 |   0 | 中国     |  6 | 1               | 141
(6 rows)

-- 扩展场景，sys_connect_by_path(123, '-') is not null
explain
select t1.id,t1.pid,t1.name,LEVEL le,connect_by_root(1), connect_by_root(id), sys_connect_by_path(123, '-')
from test_hcb_ptb t1
where sys_connect_by_path(123, '-') is not null
start with id = 141
connect by prior pid=id;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Result  (cost=37.11..40.14 rows=101 width=190)
   One-Time Filter: (sys_connect_by_path('123'::text, '-'::text) IS NOT NULL)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..37.11 rows=101 width=102)
           Start With pseudo atts: RUITR, array_key_9, array_col_1
           ->  Recursive Union  (cost=0.00..37.11 rows=101 width=102)
                 ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.80 rows=1 width=102)
                       Filter: (id = 141)
                 ->  Hash Join  (cost=0.33..3.23 rows=10 width=102)
                       Hash Cond: (t1.id = tmp_reuslt."t1@pid")
                       ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.64 rows=64 width=102)
                       ->  Hash  (cost=0.20..0.20 rows=10 width=4)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
   ->  CTE Scan on tmp_reuslt  (cost=0.00..2.02 rows=101 width=190)
(14 rows)

create table ctI as select t1.id,t1.pid,t1.name,level as le from test_hcb_ptb t1 start with id=141 connect by prior id=pid;
create table ctII as select t1.id,t1.pid,t1.name,level from test_hcb_ptb t1 start with id=141 connect by prior id=pid;
\d ctI;
             Table "swtest.cti"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 id     | integer               | 
 pid    | integer               | 
 name   | character varying(80) | 
 le     | integer               | 

\d ctII;
            Table "swtest.ctii"
 Column |         Type          | Modifiers 
--------+-----------------------+-----------
 id     | integer               | 
 pid    | integer               | 
 name   | character varying(80) | 
 level  | integer               | 

drop table ctI;
drop table ctII;
/*
 * NOTE: need do upgrade change to have syc_conenct_by_path()/connect_by_root() to be volatile
 */
/*
select t1.id,t1.pid,t1.name,LEVEL le,connect_by_root(1), connect_by_root(id), sys_connect_by_path(123, '-')
from test_hcb_ptb t1
where sys_connect_by_path(123, '-') is not null
start with id = 141
connect by prior pid=id;
*/
-- 扩展场景，sys_connect_by_path(123, '-') 验证能够被正确匹配
explain
select t1.id,t1.pid,t1.name,LEVEL le,connect_by_root(1), connect_by_root(id), sys_connect_by_path(123, '-')
from test_hcb_ptb t1
where sys_connect_by_path(123, '-') like '-123-123-123%'
start with id = 141
connect by prior pid=id;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Result  (cost=37.11..40.14 rows=101 width=190)
   One-Time Filter: (sys_connect_by_path('123'::text, '-'::text) ~~ '-123-123-123%'::text)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..37.11 rows=101 width=102)
           Start With pseudo atts: RUITR, array_key_9, array_col_1
           ->  Recursive Union  (cost=0.00..37.11 rows=101 width=102)
                 ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.80 rows=1 width=102)
                       Filter: (id = 141)
                 ->  Hash Join  (cost=0.33..3.23 rows=10 width=102)
                       Hash Cond: (t1.id = tmp_reuslt."t1@pid")
                       ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.64 rows=64 width=102)
                       ->  Hash  (cost=0.20..0.20 rows=10 width=4)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
   ->  CTE Scan on tmp_reuslt  (cost=0.01..2.02 rows=101 width=190)
(14 rows)

/*
 * NOTE: need do upgrade change to have syc_conenct_by_path()/connect_by_root() to be volatile
 */
/*
select t1.id,t1.pid,t1.name,LEVEL le,connect_by_root(1), connect_by_root(id), sys_connect_by_path(123, '-')
from test_hcb_ptb t1
where sys_connect_by_path(123, '-') like '-123-123-123%'
start with id = 141
connect by prior pid=id;
*/
/* testing distinct qualifier */
select distinct id,pid,name,LEVEL from t1 start with id = 1 connect by prior pid=id order by 1;
 id | pid | name | level 
----+-----+------+-------
  1 |   0 | 1    |     1
(1 row)

/* testing NOT expression */
select t1.id, t1.pid, t1.name from t1 start with not id=1 connect by prior pid=id;
 id | pid | name 
----+-----+------
  2 |   1 | 2
  3 |   0 | 3
  4 |   1 | 4
  5 |   2 | 5
  6 |   3 | 6
  7 |   4 | 7
  8 |   4 | 8
  9 |   7 | 9
  1 |   0 | 1
  1 |   0 | 1
  2 |   1 | 2
  3 |   0 | 3
  4 |   1 | 4
  4 |   1 | 4
  7 |   4 | 7
  1 |   0 | 1
  1 |   0 | 1
  1 |   0 | 1
  4 |   1 | 4
  1 |   0 | 1
(20 rows)

/* testing func expr in connect by clause */
explain select trim(t1.name) from test_hcb_ptb t1 connect by trim(t1.name) is not null;
                                            QUERY PLAN                                            
--------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=13471.92..22689.36 rows=409664 width=178)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..13471.92 rows=409664 width=102)
           Start With pseudo atts: RUITR
           ->  Recursive Union  (cost=0.00..13471.92 rows=409664 width=102)
                 ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.64 rows=64 width=102)
                 ->  Nested Loop  (cost=0.00..527.60 rows=40960 width=102)
                       ->  WorkTable Scan on tmp_reuslt  (cost=0.00..12.80 rows=640 width=0)
                       ->  Materialize  (cost=0.00..2.96 rows=64 width=102)
                             ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.64 rows=64 width=102)
(10 rows)

/* fix create table as with start with */
create table ct as select t1.id,t1.pid,t1.name,level from test_hcb_ptb t1 start with id=141 connect by prior id=pid;
drop table ct;
set current_schema = public;
create table t1(c1 int,c2 int,c3 int);
insert into t1 values(1,1,1);
insert into t1 values(2,2,2);
select *, connect_by_iscycle from t1 start with c1=1 connect by nocycle prior c1=c2 order siblings by 1,2;
 c1 | c2 | c3 | connect_by_iscycle 
----+----+----+--------------------
  1 |  1 |  1 |                  0
  1 |  1 |  1 |                  1
(2 rows)

insert into t1 values(1,1,1);
insert into t1 values(2,2,2);
select *, connect_by_iscycle from t1 start with c1=1 connect by nocycle prior c1=c2 order siblings by 1,2;
 c1 | c2 | c3 | connect_by_iscycle 
----+----+----+--------------------
  1 |  1 |  1 |                  0
  1 |  1 |  1 |                  0
  1 |  1 |  1 |                  1
(3 rows)

insert into t1 values(1,NULL,1);
select *, connect_by_iscycle from t1 start with c1=1 connect by nocycle prior c1=c2 order siblings by 1,2 nulls first;
 c1 | c2 | c3 | connect_by_iscycle 
----+----+----+--------------------
  1 |    |  1 |                  0
  1 |  1 |  1 |                  0
  1 |  1 |  1 |                  0
  1 |  1 |  1 |                  1
(4 rows)

select *, connect_by_iscycle from t1 start with c1=1 connect by nocycle prior c1=c2 order siblings by 1,2 nulls last;
 c1 | c2 | c3 | connect_by_iscycle 
----+----+----+--------------------
  1 |  1 |  1 |                  0
  1 |  1 |  1 |                  0
  1 |    |  1 |                  0
  1 |  1 |  1 |                  1
(4 rows)

delete from t1 where c2 is null;
select *, connect_by_iscycle from t1 start with c1<3 connect by nocycle prior c1<c2 order siblings by NLSSORT (c1, ' NLS_SORT = generic_m_ci ');
 c1 | c2 | c3 | connect_by_iscycle 
----+----+----+--------------------
  1 |  1 |  1 |                  0
  2 |  2 |  2 |                  0
  2 |  2 |  2 |                  0
  1 |  1 |  1 |                  0
  2 |  2 |  2 |                  0
  2 |  2 |  2 |                  0
  2 |  2 |  2 |                  0
  2 |  2 |  2 |                  0
(8 rows)

select max(c1) + level from t1 connect by prior c1 = c2;
ERROR:  column "tmp_reuslt.level" must appear in the GROUP BY clause or be used in an aggregate function
LINE 1: select max(c1) + level from t1 connect by prior c1 = c2;
                         ^
DETAIL:  Please check your start with rewrite table's column.
select * from t1 connect by cast(level as bigint) < 3;
 c1 | c2 | c3 
----+----+----
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
(20 rows)

select * from t1 connect by cast(level as int4) < 3;
 c1 | c2 | c3 
----+----+----
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
(20 rows)

explain select * from t1 connect by level is not null;
                                           QUERY PLAN                                           
------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=12299132.73..19865221.62 rows=378304445 width=12)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..12299132.73 rows=378304445 width=12)
           Start With pseudo atts: RUITR
           ->  Recursive Union  (cost=0.00..12299132.73 rows=378304445 width=12)
                 ->  Seq Scan on t1  (cost=0.00..29.45 rows=1945 width=12)
                 ->  Nested Loop  (cost=0.00..473301.44 rows=37830250 width=12)
                       ->  WorkTable Scan on tmp_reuslt  (cost=0.00..389.00 rows=19450 width=0)
                       ->  Materialize  (cost=0.00..39.17 rows=1945 width=12)
                             ->  Seq Scan on t1  (cost=0.00..29.45 rows=1945 width=12)
(10 rows)

select * from t1 connect by level is not null and level < 3;
 c1 | c2 | c3 
----+----+----
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
  1 |  1 |  1
  2 |  2 |  2
(20 rows)

select * from t1 connect by level;
ERROR:  Unsupported expression found in CONNECT BY clause.
DETAIL:  Pseudo column expects an operator
select t1.id a.d jack from t1;
ERROR:  Invalid use of identifiers.
LINE 1: select t1.id a.d jack from t1;
                     ^
DETAIL:  Syntax error found near token "a"
select t1.id bauer jack from t1;
ERROR:  Invalid use of identifiers.
LINE 1: select t1.id bauer jack from t1;
                     ^
DETAIL:  Syntax error found near token "bauer"
drop table t1;
/* limit + startwith 场景下执行阶段targetlist报错 */
CREATE TABLE log_part (
    ts timestamp(6) without time zone DEFAULT now() NOT NULL,
    op character(1),
    act_no numeric(38,0),
    old_blc numeric(38,0),
    num numeric(38,0),
    threadid bigint,
    index integer,
    tran integer
)
WITH (orientation=row, compression=no)
PARTITION BY RANGE (ts)
INTERVAL('1 day')
(
    PARTITION p_2020_05_21 VALUES LESS THAN ('2020-05-21') TABLESPACE pg_default
)
ENABLE ROW MOVEMENT;
insert into log_part values('2021-09-24 10:12:19.451125','m',255, 10000000, -374929792,  39, 0, 0);
insert into log_part values('2021-09-24 10:12:19.451125','a',548, 10000000,  374929792,  39, 0, 0);
insert into log_part values('2021-09-24 10:12:19.449826','m', 39, 10000000, -473910067,  97, 0, 0);
insert into log_part values('2021-09-24 10:12:19.451221','m',250, 10000000, -757146539,  63, 0, 0);
insert into log_part values('2021-09-24 10:12:19.449643','m',916, 10000000, -418707874, 100, 0, 0);
insert into log_part values('2021-09-24 10:12:19.451052','m',510, 10000000, -868384331,  45, 0, 0);
insert into log_part values('2021-09-24 10:12:19.451039','m',541, 10000000, -782801693, 101, 0, 0);
insert into log_part values('2021-09-24 10:12:19.450232','m',  4, 10000000, -794225803,  33, 0, 0);
insert into log_part values('2021-09-24 10:12:19.450352','m',123, 10000000, -494836087,  58, 0, 0);
insert into log_part values('2021-09-24 10:12:19.449622','m',876, 10000000,  -79442930,  60, 0, 0);
insert into log_part values('2021-09-24 10:12:19.449785','m', 21, 10000000, -560326111,  65, 0, 0);
insert into log_part values('2021-09-24 10:12:19.449828','m',484, 10000000, -571750221,  29, 0, 0);
insert into log_part values('2021-09-24 10:12:19.449657','m',167, 10000000, -146895512, 106, 0, 0);
insert into log_part values('2021-09-24 10:12:19.449826','a', 35, 10000000,  473910067,  97, 0, 0);
insert into log_part values('2021-09-24 10:12:19.451221','a',540, 10000000,  757146539,  63, 0, 0);
insert into log_part values('2021-09-24 10:12:19.449706','m',118, 10000000, -318894193,  50, 0, 0);
insert into log_part values('2021-09-24 10:12:19.501816','m',105, 10000000, -997671676,  39, 0, 0);
insert into log_part values('2021-09-24 10:12:19.449602','m',858, 10000000, -207656402,  28, 0, 0);
insert into log_part values('2021-09-24 10:12:19.450566','m',607, 10000000, -479468765,  30, 0, 0);
insert into log_part values('2021-09-24 10:12:19.451052','a',132, 10000000,  868384331,  45, 0, 0);
insert into log_part values('2021-09-24 10:12:19.451039','a',891, 10000000,  782801693, 101, 0, 0);
explain
select * from (select * from log_part where act_no=250)
start with old_blc=10000000 connect by prior old_blc + prior num = old_blc and act_no=prior act_no limit 10;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=188.10..188.30 rows=10 width=122)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..188.10 rows=11 width=122)
           Start With pseudo atts: RUITR, array_key_3, array_key_4, array_key_5
           ->  Recursive Union  (cost=0.00..188.10 rows=11 width=122)
                 ->  Partition Iterator  (cost=0.00..18.05 rows=1 width=122)
                       Iterations: 2
                       ->  Partitioned Seq Scan on log_part  (cost=0.00..18.05 rows=1 width=122)
                             Filter: ((act_no = 250::numeric) AND (old_blc = 10000000::numeric))
                             Selected Partitions:  1..2
                 ->  Nested Loop  (cost=0.00..16.98 rows=1 width=122)
                       Join Filter: ((tmp_reuslt."sw_subquery_0@old_blc" + tmp_reuslt."sw_subquery_0@num") = public.log_part.old_blc)
                       ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.22 rows=1 width=90)
                             Filter: ("sw_subquery_0@act_no" = 250::numeric)
                       ->  Partition Iterator  (cost=0.00..16.71 rows=3 width=122)
                             Iterations: 2
                             ->  Partitioned Seq Scan on log_part  (cost=0.00..16.71 rows=3 width=122)
                                   Filter: (act_no = 250::numeric)
                                   Selected Partitions:  1..2
   ->  Result  (cost=0.00..0.22 rows=11 width=122)
         ->  CTE Scan on tmp_reuslt  (cost=0.00..0.22 rows=11 width=122)
(21 rows)

select * from (select * from log_part where act_no=250)
start with old_blc=10000000 connect by prior old_blc + prior num = old_blc and act_no=prior act_no limit 10;
               ts                | op | act_no | old_blc  |    num     | threadid | index | tran 
---------------------------------+----+--------+----------+------------+----------+-------+------
 Fri Sep 24 10:12:19.451221 2021 | m  |    250 | 10000000 | -757146539 |       63 |     0 |    0
(1 row)

explain
select *, connect_by_root old_blc from (select * from log_part where act_no=250)
start with old_blc=10000000 connect by prior old_blc + prior num = old_blc and act_no=prior act_no limit 10;
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=188.10..188.35 rows=10 width=122)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..188.10 rows=11 width=122)
           Start With pseudo atts: RUITR, array_key_3, array_key_4, array_key_5, array_col_4
           ->  Recursive Union  (cost=0.00..188.10 rows=11 width=122)
                 ->  Partition Iterator  (cost=0.00..18.05 rows=1 width=122)
                       Iterations: 2
                       ->  Partitioned Seq Scan on log_part  (cost=0.00..18.05 rows=1 width=122)
                             Filter: ((act_no = 250::numeric) AND (old_blc = 10000000::numeric))
                             Selected Partitions:  1..2
                 ->  Nested Loop  (cost=0.00..16.98 rows=1 width=122)
                       Join Filter: ((tmp_reuslt."sw_subquery_0@old_blc" + tmp_reuslt."sw_subquery_0@num") = public.log_part.old_blc)
                       ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.22 rows=1 width=90)
                             Filter: ("sw_subquery_0@act_no" = 250::numeric)
                       ->  Partition Iterator  (cost=0.00..16.71 rows=3 width=122)
                             Iterations: 2
                             ->  Partitioned Seq Scan on log_part  (cost=0.00..16.71 rows=3 width=122)
                                   Filter: (act_no = 250::numeric)
                                   Selected Partitions:  1..2
   ->  Result  (cost=0.00..0.28 rows=11 width=122)
         ->  CTE Scan on tmp_reuslt  (cost=0.00..0.28 rows=11 width=122)
(21 rows)

select *, connect_by_root old_blc from (select * from log_part where act_no=250)
start with old_blc=10000000 connect by prior old_blc + prior num = old_blc and act_no=prior act_no limit 10;
               ts                | op | act_no | old_blc  |    num     | threadid | index | tran | connect_by_rootold_blc 
---------------------------------+----+--------+----------+------------+----------+-------+------+------------------------
 Fri Sep 24 10:12:19.451221 2021 | m  |    250 | 10000000 | -757146539 |       63 |     0 |    0 | 10000000
(1 row)

select *, connect_by_root old_blc alias_old_blc from (select * from log_part where act_no=250)
start with old_blc=10000000 connect by prior old_blc + prior num = old_blc and act_no=prior act_no limit 10;
               ts                | op | act_no | old_blc  |    num     | threadid | index | tran | alias_old_blc 
---------------------------------+----+--------+----------+------------+----------+-------+------+---------------
 Fri Sep 24 10:12:19.451221 2021 | m  |    250 | 10000000 | -757146539 |       63 |     0 |    0 | 10000000
(1 row)

SELECT *, CONNECT_BY_ROOT old_blc AS alias_old_blc FROM (SELECT * FROM log_part WHERE act_no=250)
START WITH old_blc=10000000 CONNECT BY PRIOR old_blc + PRIOR num = old_blc AND act_no = PRIOR act_no LIMIT 10;
               ts                | op | act_no | old_blc  |    num     | threadid | index | tran | alias_old_blc 
---------------------------------+----+--------+----------+------------+----------+-------+------+---------------
 Fri Sep 24 10:12:19.451221 2021 | m  |    250 | 10000000 | -757146539 |       63 |     0 |    0 | 10000000
(1 row)

explain
select op , act_no , old_blc , num , threadid , index , tran ,level from log_part
start with old_blc=10000000 connect by prior old_blc + prior num = old_blc and act_no=prior act_no
order by 1,2,3,4 limit 10;
                                                                                       QUERY PLAN                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=228.76..228.79 rows=10 width=118)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..228.26 rows=13 width=122)
           Start With pseudo atts: RUITR, array_key_3, array_key_4, array_key_5
           ->  Recursive Union  (cost=0.00..228.26 rows=13 width=122)
                 ->  Partition Iterator  (cost=0.00..16.71 rows=3 width=122)
                       Iterations: 2
                       ->  Partitioned Seq Scan on log_part  (cost=0.00..16.71 rows=3 width=122)
                             Filter: (old_blc = 10000000::numeric)
                             Selected Partitions:  1..2
                 ->  Hash Join  (cost=1.05..21.13 rows=1 width=122)
                       Hash Cond: ((public.log_part.old_blc = (tmp_reuslt."log_part@old_blc" + tmp_reuslt."log_part@num")) AND (public.log_part.act_no = tmp_reuslt."log_part@act_no"))
                       ->  Partition Iterator  (cost=0.00..15.37 rows=537 width=122)
                             Iterations: 2
                             ->  Partitioned Seq Scan on log_part  (cost=0.00..15.37 rows=537 width=122)
                                   Selected Partitions:  1..2
                       ->  Hash  (cost=0.60..0.60 rows=30 width=90)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.60 rows=30 width=90)
   ->  Sort  (cost=0.50..0.53 rows=13 width=118)
         Sort Key: tmp_reuslt."log_part@op", tmp_reuslt."log_part@act_no", tmp_reuslt."log_part@old_blc", tmp_reuslt."log_part@num"
         ->  CTE Scan on tmp_reuslt  (cost=0.00..0.26 rows=13 width=118)
(21 rows)

select op , act_no , old_blc , num , threadid , index , tran ,level from log_part
start with old_blc=10000000 connect by prior old_blc + prior num = old_blc and act_no=prior act_no
order by 1,2,3,4 limit 10;
 op | act_no | old_blc  |    num     | threadid | index | tran | level 
----+--------+----------+------------+----------+-------+------+-------
 a  |     35 | 10000000 |  473910067 |       97 |     0 |    0 |     1
 a  |    132 | 10000000 |  868384331 |       45 |     0 |    0 |     1
 a  |    540 | 10000000 |  757146539 |       63 |     0 |    0 |     1
 a  |    548 | 10000000 |  374929792 |       39 |     0 |    0 |     1
 a  |    891 | 10000000 |  782801693 |      101 |     0 |    0 |     1
 m  |      4 | 10000000 | -794225803 |       33 |     0 |    0 |     1
 m  |     21 | 10000000 | -560326111 |       65 |     0 |    0 |     1
 m  |     39 | 10000000 | -473910067 |       97 |     0 |    0 |     1
 m  |    105 | 10000000 | -997671676 |       39 |     0 |    0 |     1
 m  |    118 | 10000000 | -318894193 |       50 |     0 |    0 |     1
(10 rows)

drop table log_part;
set current_schema=swtest;
EXPLAIN SELECT * FROM test_area START WITH name = '中国' CONNECT BY PRIOR id = fatherid limit 10;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Limit  (cost=23.91..24.11 rows=10 width=72)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..23.91 rows=221 width=24)
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union  (cost=0.00..23.91 rows=221 width=24)
                 ->  Seq Scan on test_area  (cost=0.00..1.27 rows=1 width=24)
                       Filter: (name = '中国'::text)
                 ->  Hash Join  (cost=0.33..1.82 rows=22 width=24)
                       Hash Cond: (swtest.test_area.fatherid = tmp_reuslt."test_area@id")
                       ->  Seq Scan on test_area  (cost=0.00..1.22 rows=22 width=24)
                       ->  Hash  (cost=0.20..0.20 rows=10 width=4)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
   ->  Result  (cost=0.00..4.42 rows=221 width=72)
         ->  CTE Scan on tmp_reuslt  (cost=0.00..4.42 rows=221 width=72)
(14 rows)

SELECT * FROM test_area START WITH name = '中国' CONNECT BY PRIOR id = fatherid limit 10;
 id |  name  | fatherid | name_desc 
----+--------+----------+-----------
  1 | 中国   |        0 | China
  2 | 湖南省 |        1 | Hunan
  3 | 广东省 |        1 | Guangdong
  4 | 海南省 |        1 | Hainan
  5 | 河北省 |        1 | Hebei
  6 | 河南省 |        1 | Henan
  7 | 山东省 |        1 | Shandong
  8 | 湖北省 |        1 | Hubei
  9 | 江苏省 |        1 | Jiangsu
 10 | 深圳市 |        3 | Shenzhen
(10 rows)

set max_recursive_times=100000000;
create table tt22(x int);
create or replace view dual as select 'x' x;
insert into tt22 select level from dual connect by level <=1000000;
select count(*) from tt22;
  count  
---------
 1000000
(1 row)

set max_recursive_times=200;
insert into tt22 select level from dual connect by level <=1000000;
ERROR:  Current Start With...Connect by has exceeded max iteration times 200
HINT:  Please check your connect by clause carefully
drop table tt22;
/* 修复RecursiveUnion的inner分支备planning成BaseResult节点 */
explain select t1.id,t1.pid,t1.name from test_hcb_ptb t1 start with id=141 connect by (prior pid)=id and prior pid>10 and 1=0;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=3.12..3.34 rows=11 width=186)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..3.12 rows=11 width=102)
           Start With pseudo atts: RUITR, array_key_9
           ->  Recursive Union  (cost=0.00..3.12 rows=11 width=102)
                 ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.80 rows=1 width=102)
                       Filter: (id = 141)
                 ->  Result  (cost=0.00..0.01 rows=1 width=0)
                       One-Time Filter: false
(9 rows)

select t1.id,t1.pid,t1.name from test_hcb_ptb t1 start with id=141 connect by (prior pid)=id and prior pid>10 and 1=0;
 id  | pid |   name   
-----+-----+----------
 141 | 131 | 江南摩卡
(1 row)

explain select t1.id,t1.pid,t1.name from test_hcb_ptb t1 start with id=141 connect by (prior pid)=id and prior pid>10 and null;
                                     QUERY PLAN                                      
-------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=3.12..3.34 rows=11 width=186)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..3.12 rows=11 width=102)
           Start With pseudo atts: RUITR, array_key_9
           ->  Recursive Union  (cost=0.00..3.12 rows=11 width=102)
                 ->  Seq Scan on test_hcb_ptb t1  (cost=0.00..2.80 rows=1 width=102)
                       Filter: (id = 141)
                 ->  Result  (cost=0.00..0.01 rows=1 width=0)
                       One-Time Filter: false
(9 rows)

select t1.id,t1.pid,t1.name from test_hcb_ptb t1 start with id=141 connect by (prior pid)=id and prior pid>10 and null;
 id  | pid |   name   
-----+-----+----------
 141 | 131 | 江南摩卡
(1 row)

/* connect by level/rownum 不支持not并且in 数据不准确 */
create table core_060(id varchar);
insert into core_060 values ('a'),('b'),('c');
SELECT id,level FROM core_060 CONNECT BY level in (1,2);
 id | level 
----+-------
 a  |     1
 b  |     1
 c  |     1
 a  |     2
 b  |     2
 c  |     2
 a  |     2
 b  |     2
 c  |     2
 a  |     2
 b  |     2
 c  |     2
(12 rows)

SELECT id,level FROM core_060 CONNECT BY not (level>2);
 id | level 
----+-------
 a  |     1
 b  |     1
 c  |     1
 a  |     2
 b  |     2
 c  |     2
 a  |     2
 b  |     2
 c  |     2
 a  |     2
 b  |     2
 c  |     2
(12 rows)

SELECT id,level FROM core_060 CONNECT BY cast(level as number(38,0))<3;
 id | level 
----+-------
 a  |     1
 b  |     1
 c  |     1
 a  |     2
 b  |     2
 c  |     2
 a  |     2
 b  |     2
 c  |     2
 a  |     2
 b  |     2
 c  |     2
(12 rows)

drop table core_060;
/* 存在子查询时，随着数据递归层数的增加，性能下降明显 */
create table t_customer(id int, pid int,num int,depth int);
-- verify nestloop can be material-optimized
set enable_hashjoin = off;
set enable_mergejoin = off;
explain
select * from ( select * from t_customer where id<1200040 and id>=1200000) start with id=1200010 connect by prior id=pid;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=423.43..423.65 rows=11 width=16)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..423.43 rows=11 width=16)
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union  (cost=0.00..423.43 rows=11 width=16)
                 ->  Seq Scan on t_customer  (cost=0.00..41.08 rows=1 width=16)
                       Filter: ((id < 1200040) AND (id >= 1200000) AND (id = 1200010))
                 ->  Nested Loop  (cost=0.00..38.21 rows=1 width=16)
                       Join Filter: (tmp_reuslt."sw_subquery_0@id" = swtest.t_customer.pid)
                       ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
                       ->  Materialize  (cost=0.00..36.69 rows=9 width=16)
                             ->  Seq Scan on t_customer  (cost=0.00..36.64 rows=9 width=16)
                                   Filter: ((id < 1200040) AND (id >= 1200000))
(13 rows)

select * from ( select * from t_customer where id<1200040 and id>=1200000) start with id=1200010 connect by prior id=pid;
 id | pid | num | depth 
----+-----+-----+-------
(0 rows)

reset enable_hashjoin;
reset enable_mergejoin;
-- verify nestloop can be material-optimized
set enable_nestloop = off;
set enable_mergejoin = off;
explain
select * from ( select * from t_customer where id<1200040 and id>=1200000) start with id=1200010 connect by prior id=pid;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=411.29..411.51 rows=11 width=16)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..411.29 rows=11 width=16)
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union  (cost=0.00..411.29 rows=11 width=16)
                 ->  Seq Scan on t_customer  (cost=0.00..41.08 rows=1 width=16)
                       Filter: ((id < 1200040) AND (id >= 1200000) AND (id = 1200010))
                 ->  Hash Join  (cost=0.33..37.00 rows=1 width=16)
                       Hash Cond: (swtest.t_customer.pid = tmp_reuslt."sw_subquery_0@id")
                       ->  Materialize  (cost=0.00..36.64 rows=9 width=16)
                             ->  Seq Scan on t_customer  (cost=0.00..36.64 rows=9 width=16)
                                   Filter: ((id < 1200040) AND (id >= 1200000))
                       ->  Hash  (cost=0.20..0.20 rows=10 width=4)
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
(14 rows)

select * from ( select * from t_customer where id<1200040 and id>=1200000) start with id=1200010 connect by prior id=pid;
 id | pid | num | depth 
----+-----+-----+-------
(0 rows)

reset enable_nestloop;
reset enable_mergejoin;
-- verify mergejoin is no need to be material-optimized
set enable_hashjoin = off;
set enable_nestloop = off;
explain
select * from ( select * from t_customer where id<1200040 and id>=1200000) start with id=1200010 connect by prior id=pid;
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 CTE Scan on tmp_reuslt  (cost=413.84..414.06 rows=11 width=16)
   CTE tmp_reuslt
     ->  StartWith Operator  (cost=0.00..413.84 rows=11 width=16)
           Start With pseudo atts: RUITR, array_key_1
           ->  Recursive Union  (cost=0.00..413.84 rows=11 width=16)
                 ->  Seq Scan on t_customer  (cost=0.00..41.08 rows=1 width=16)
                       Filter: ((id < 1200040) AND (id >= 1200000) AND (id = 1200010))
                 ->  Merge Join  (cost=37.15..37.25 rows=1 width=16)
                       Merge Cond: (tmp_reuslt."sw_subquery_0@id" = swtest.t_customer.pid)
                       ->  Sort  (cost=0.37..0.39 rows=10 width=4)
                             Sort Key: tmp_reuslt."sw_subquery_0@id"
                             ->  WorkTable Scan on tmp_reuslt  (cost=0.00..0.20 rows=10 width=4)
                       ->  Sort  (cost=36.78..36.81 rows=9 width=16)
                             Sort Key: swtest.t_customer.pid
                             ->  Seq Scan on t_customer  (cost=0.00..36.64 rows=9 width=16)
                                   Filter: ((id < 1200040) AND (id >= 1200000))
(16 rows)

select * from ( select * from t_customer where id<1200040 and id>=1200000) start with id=1200010 connect by prior id=pid;
 id | pid | num | depth 
----+-----+-----+-------
(0 rows)

reset enable_mergejoin;
reset enable_nestloop;
reset enable_hashjoin;
drop table t_customer;
-- test correlated sublink
create table test_place as select id, name, tex from test_hcb_ptb;
select t1.id,t1.pid,t1.name from test_hcb_ptb t1 start with not exists(select * from test_place where id=t1.id and id !=141) connect by prior pid=id;
 id  | pid |   name   
-----+-----+----------
 141 | 131 | 江南摩卡
 131 | 121 | 东山街
 121 | 111 | 江宁区
 111 |  11 | 南京市
  11 |   1 | 江苏省
   1 |   0 | 中国
(6 rows)

drop table test_place;
-- test where quals pushdown
drop table if exists brand_sw3 cascade;
create table brand_sw3
(
mfg varchar(500) primary key ,
brand_cd varchar(500) ,
brand_name varchar(100) ,
brand_party_id number(18,10) NULL,c1 serial
);
drop table if exists usview17_sw3 cascade;
create table usview17_sw3
(
brand_party_id numeric(18,2) ,
sales_tran_id numeric(12,5) ,
item_qty numeric(5,0) ,
mkb_cost_amt numeric(19,4) ,
mkb_exp numeric
);
SELECT MAX(t2.brand_party_id)-COUNT(t2.sales_tran_id)
FROM brand_sw3 t1,usview17_sw3 t2
WHERE t1.brand_name=PRIOR t1.brand_name
AND PRIOR t1.brand_cd IS NOT NULL
START WITH t1.mfg=t1.brand_name
CONNECT BY NOCYCLE PRIOR t1.mfg
BETWEEN t1.brand_name
AND PRIOR t1.brand_name ;
 ?column? 
----------
         
(1 row)

SELECT MAX(t2.brand_party_id)-COUNT(t2.sales_tran_id)
FROM brand_sw3 t1,usview17_sw3 t2
where t1.brand_cd IS NOT NULL CONNECT BY rownum < 3;
 ?column? 
----------
         
(1 row)

drop table if exists brand_sw3 cascade;
drop table if exists usview17_sw3 cascade;
create table sw_test1(c0 int);
create table sw_test2(c0 text);
select * from sw_test1,sw_test2 where true connect by true;
 c0 | c0 
----+----
(0 rows)

drop table sw_test1;
drop table sw_test2;
