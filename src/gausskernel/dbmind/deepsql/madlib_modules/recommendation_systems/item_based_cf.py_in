# -*- coding:utf-8 -*-
# Copyright (c) 2020 Huawei Technologies Co.,Ltd.
#
# openGauss is licensed under Mulan PSL v2.
# You can use this software according to the terms
# and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#
#          http://license.coscl.org.cn/MulanPSL2
#
# THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS,
# WITHOUT WARRANTIES OF ANY KIND,
# EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
# MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
# See the Mulan PSL v2 for more details.
# ----------------------------------------------------------------------------

from collections import defaultdict
from operator import itemgetter
import math
import random
import plpy
import json

from utilities.validate_args import quote_ident
from utilities.validate_args import table_exists

def train_validate(train_table, user_varname, item_varname,
            rating_varname, k_sim_item, use_iuf_similarity, 
            test_table, n_rec_item):
    if not train_table or not user_varname or not item_varname or not rating_varname or not k_sim_item or k_sim_item < 1:
        plpy.error("The input parameters are invalid.")
    if not use_iuf_similarity:
        use_iuf_similarity = False
    if not test_table:
        test_table = None
    if not n_rec_item and n_rec_item != 0:
        n_rec_item = 10
    elif n_rec_item <= 0:
        plpy.error("The input parameters are invalid.")
    return use_iuf_similarity, test_table, n_rec_item

def train(schema_madlib, train_table, user_varname, item_varname,
            rating_varname, k_sim_item, use_iuf_similarity, 
            test_table, n_rec_item, **kwargs):

    # 0) Validate input parameter
    use_iuf_similarity, test_table, n_rec_item=train_validate(train_table, 
            user_varname, item_varname, rating_varname, k_sim_item, 
            use_iuf_similarity, test_table, n_rec_item)

    # 1) Generate user-item-rating matrix
    sql = """select {user_varname}, {item_varname}, {rating_varname} from {train_table};""".format(
            user_varname=quote_ident(user_varname),
            item_varname=quote_ident(item_varname),
            rating_varname=quote_ident(rating_varname),
            train_table=train_table
        )
    results = plpy.execute(sql)
    
    user_item_rating_mat = defaultdict(dict)
    for result in results:
        user_item_rating_mat[result[user_varname]][result[item_varname]] = result[rating_varname]

    # 2) Generate item-item-similarity matrix 
    # 2.1) Set item_item_sim_table name
    if use_iuf_similarity:
        item_item_sim_table = train_table+'_itemcf_iuf_sim'
    else:
        item_item_sim_table = train_table+'_itemcf_sim'

    # 2.2) First time generate item_item_sim_table
    if not table_exists(item_item_sim_table):
        # 2.2.1) Get item popular
        item_popular = defaultdict(int)
        for user, items in user_item_rating_mat.items():
            for item in items:
                item_popular[item] += 1

        # 2.2.2) Make item_item_sim_mat
        item_item_sim_mat_val = {}
        item_item_sim_mat_sum = {}
        for user, items in user_item_rating_mat.items():
            for itemi in items:
                item_item_sim_mat_val.setdefault(itemi, defaultdict(float))
                item_item_sim_mat_sum.setdefault(itemi, defaultdict(float))
                len_itemi = item_popular[itemi]
                for itemj in items:
                    len_itemj = item_popular[itemj]
                    if itemi == itemj:
                        continue
                    if use_iuf_similarity:
                        item_item_sim_mat_val[itemi][itemj] += 1 / math.log(1 + len(items))
                        item_item_sim_mat_sum[itemi][itemj] = item_item_sim_mat_val[itemi][itemj]/math.sqrt(len_itemi*len_itemj)
                    else:
                        item_item_sim_mat_val[itemi][itemj] += 1
                        item_item_sim_mat_sum[itemi][itemj] = item_item_sim_mat_val[itemi][itemj]/math.sqrt(len_itemi*len_itemj)        
        
        # 2.2.3) store item_item_sim_mat
        sql = """drop table if exists {item_item_sim_table};
                create table {item_item_sim_table} (itemid integer, sim_item json);""".format(
                item_item_sim_table=item_item_sim_table
                )
        plpy.execute(sql)
        
        for itemid, items in item_item_sim_mat_sum.items():
            items_json = json.dumps(items)
            sql = """insert into {item_item_sim_table} values ({itemid}, $${items_json}$$);""".format(
                item_item_sim_table=item_item_sim_table,
                itemid=itemid,
                items_json=items_json
            )
            plpy.execute(sql)
    
    # 2.3) Read item_item_sim_table
    sql = """select * from {item_item_sim_table};""".format(
                item_item_sim_table=item_item_sim_table,
            )
    results = plpy.execute(sql)
    
    item_item_sim_mat = {}
    for result in results:
        itemi = result['itemid']
        item_item_sim_mat.setdefault(itemi, defaultdict(float))
        items_json = json.loads(result['sim_item'])
        for itemj, itemi_itemj_sim in items_json.items():
            item_item_sim_mat[itemi][int(itemj)] = itemi_itemj_sim
    
    # 3) Generate user-item-score matrix
    # 3.1) Make user_item_score table 
    user_item_score_mat = {}
    for user, items in user_item_rating_mat.items():
        user_item_score_mat.setdefault(user, defaultdict(float))
        for itemi, rating in items.items():
            for itemj, similarity in sorted(item_item_sim_mat[itemi].items(), key=itemgetter(1), reverse=True)[:k_sim_item]:
                if itemj in user_item_rating_mat[user]:
                    continue
                user_item_score_mat[user][itemj] += similarity * rating
    
    # 3.2) Store user_item_score_mat
    user_item_score_table = train_table + '_itemcf_score'
    sql = """drop table if exists {user_item_score_table};
                create table {user_item_score_table} (userid integer, scored_item json);""".format(
                user_item_score_table=user_item_score_table
                )
    plpy.execute(sql)
    
    for userid, items in user_item_score_mat.items():
        items_json = json.dumps(items)
        sql = """insert into {user_item_score_table} values ({userid}, $${items_json}$$);""".format(
            user_item_score_table=user_item_score_table,
            userid=userid,
            items_json=items_json
        )
        plpy.execute(sql)

    plpy.info('Training finish! Users\' scored items are stored in table ' + user_item_score_table)

    # 4) Test recommendation results
    if test_table:
        # 4.1) Do statistic 
        item_set = set()
        item_popular = defaultdict(int)
        for _, items in user_item_rating_mat.items():
            for item in items:
                item_set.add(item)
                item_popular[item] += 1
        item_count = len(item_set)

        # 4.2) Read true data  
        sql = """select {user_varname}, {item_varname} from {test_table};""".format(
            user_varname=quote_ident(user_varname),
            item_varname=quote_ident(item_varname),
            test_table=test_table
        )
        results = plpy.execute(sql)
    
        user_item_true_mat = defaultdict(set)
        for result in results:
            user_item_true_mat[result[user_varname]].add(result[item_varname])

        # 4.3) Test
        hit_count = 0
        rec_count = 0
        test_count = 0
        all_rec_items = set()
        popular_sum = 0
        for user in user_item_rating_mat:
            if user not in user_item_true_mat:
                continue
            true_items = user_item_true_mat[user]
            scored_items = user_item_score_mat[user]
            for item, _ in sorted(scored_items.items(), key=itemgetter(1), reverse=True)[:n_rec_item]:
                if item in true_items:
                    hit_count += 1
                all_rec_items.add(item)
                popular_sum += math.log(1 + item_popular[item])
            rec_count += n_rec_item
            test_count += len(true_items)
        precision = hit_count / (1.0 * rec_count)
        recall = hit_count / (1.0 * test_count)
        coverage = len(all_rec_items) / (1.0 * item_count)
        popularity = popular_sum / (1.0 * rec_count)
        plpy.info('Testing finish! Precision:', precision, 'Recall:', recall, 'Coverage:', coverage, 'Popularity:', popularity)

def predict_validate(train_table, predict_table, user_varname, recommend_table, n_rec_item):
    if not train_table or not predict_table or not user_varname or not recommend_table or not n_rec_item or n_rec_item < 1:
        plpy.error("The input parameters are invalid.")

def predict(schema_madlib, train_table, predict_table, user_varname, recommend_table, n_rec_item, **kwargs):
    
    # 0) Validate input parameters
    predict_validate(train_table, predict_table, user_varname, recommend_table, n_rec_item)

    # 1) Read user-item-score table
    sql = """select userid, scored_item from {user_item_score_table};""".format(
            user_item_score_table=train_table+'_itemcf_score'
        )
    results = plpy.execute(sql)

    user_item_score_mat = {}
    for result in results:
        userid = result['userid']
        user_item_score_mat.setdefault(userid, [])
        scored_items = json.loads(result['scored_item'])
        for itemid, _ in sorted(scored_items.items(), key=itemgetter(1), reverse=True)[:n_rec_item]:
            user_item_score_mat[userid].append(itemid)
    
    # 2) Read predict table
    sql = """select {user_varname} from {predict_table};""".format(
            user_varname=quote_ident(user_varname),
            predict_table=predict_table
        )
    results = plpy.execute(sql)

    users = set()
    for result in results:
        users.add(result[user_varname])
    
    # 3) Generate recommend table
    sql = """drop table if exists {recommend_table};
                create table {recommend_table} (userid integer, recommend_item integer[]);""".format(
                recommend_table=recommend_table
                )
    plpy.execute(sql)
    
    for user in users:
        if user not in user_item_score_mat:
            plpy.info("Userid", user, "is a cold-start user!")
            continue
        recommend_item = [int(x) for x in user_item_score_mat[user]]
        sql = """insert into {recommend_table} values ({userid}, array{recommend_item});""".format(
            recommend_table=recommend_table,
            userid=user,
            recommend_item=recommend_item
        )
        plpy.execute(sql)

    plpy.info('Recommending finish! Users\' recommended items are stored in table ' + recommend_table)

                
