# -*- coding:utf-8 -*-
# Copyright (c) 2020 Huawei Technologies Co.,Ltd.
#
# openGauss is licensed under Mulan PSL v2.
# You can use this software according to the terms
# and conditions of the Mulan PSL v2.
# You may obtain a copy of Mulan PSL v2 at:
#
#          http://license.coscl.org.cn/MulanPSL2
#
# THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS,
# WITHOUT WARRANTIES OF ANY KIND,
# EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT,
# MERCHANTABILITY OR FIT FOR A PARTICULAR PURPOSE.
# See the Mulan PSL v2 for more details.
# ----------------------------------------------------------------------------

from collections import defaultdict
from operator import itemgetter
import math
import random
import plpy
import json

from utilities.validate_args import quote_ident

def gen_negative_sample(items, items_list):
    samples = dict()
    for item, rate in items.items():
        samples[item] = 1
    for i in range(len(items) * 11):
        item = items_list[random.randint(0, len(items_list) - 1)]
        if item in samples:
            continue
        samples[item] = 0
        if len(samples) >= 10 * len(items):
            break
    return samples

def train_validate(train_table, user_varname, item_varname,
            rating_varname, k_factor, epochs, alpha, lamb, test_table, n_rec_item):
    if (not train_table or not user_varname or not item_varname or not rating_varname or not k_factor or k_factor < 1 
        or not epochs or epochs < 1 or not alpha or alpha < 0 or not lamb or lamb < 0):
        plpy.error("The input parameters are invalid.")
    if not test_table:
        test_table = None
    if not n_rec_item and n_rec_item != 0:
        n_rec_item = 10
    elif n_rec_item <= 0:
        plpy.error("The input parameters are invalid.")
    return test_table, n_rec_item

def train(schema_madlib, train_table, user_varname, item_varname,
            rating_varname, k_factor, epochs, alpha, lamb, 
            test_table, n_rec_item, **kwargs):

    # 0) Validate input parameters
    test_table, n_rec_item=train_validate(train_table, user_varname, item_varname,
            rating_varname, k_factor, epochs, alpha, lamb, test_table, n_rec_item)

    # 1) Generate user-item-rating matrix
    sql = """select {user_varname}, {item_varname}, {rating_varname} from {train_table};""".format(
            user_varname=quote_ident(user_varname),
            item_varname=quote_ident(item_varname),
            rating_varname=quote_ident(rating_varname),
            train_table=train_table
        )
    results = plpy.execute(sql)
    
    user_item_rating_mat = defaultdict(dict)
    for result in results:
        user_item_rating_mat[result[user_varname]][result[item_varname]] = result[rating_varname]
    
    # 2) Init and train
    # 2.1) Init user item set
    users_set, items_set = set(), set()
    items_list = []
    item_popular = defaultdict(int)
    for user, items in user_item_rating_mat.items():
        for item in items:
            item_popular[item] += 1
            users_set.add(user)
            items_set.add(item)
            items_list.append(item)
    items_count = len(items_set)

    # 2.2) Init model
    P = dict()
    Q = dict()
    for user in users_set:
        P[user] = [random.random()/math.sqrt(k_factor) for _ in range(k_factor)]
    for item in items_set:
        Q[item] = [random.random()/math.sqrt(k_factor) for _ in range(k_factor)]
    
    # 2.3) Train model
    for epoch in range(epochs):
        plpy.info('Training epoch:', epoch)
        for user in user_item_rating_mat:
            samples = gen_negative_sample(user_item_rating_mat[user], items_list)
            for item, rui in samples.items():
                rate_e = 0
                for k in range(k_factor):
                    Puk = P[user][k]
                    Qki = Q[item][k]
                    rate_e += Puk * Qki
                eui = rui - rate_e
                for k in range(k_factor):
                    P[user][k] += alpha * (eui * Q[item][k] - lamb * P[user][k])
                    Q[item][k] += alpha * (eui * P[user][k] - lamb * Q[item][k])
        alpha *= 0.9
        plpy.info(P[1],Q[1])

    # 5) Generate and store user-item-score
    user_item_score_mat = {}
    for user in users_set:
        user_item_score_mat.setdefault(user, defaultdict(float))
        interacted_items = user_item_rating_mat[user]
        for item in items_set:
            if item in interacted_items.keys():
                continue
            for k, Qik in enumerate(Q[item]):
                user_item_score_mat[user][item] += P[user][k] * Qik

    user_item_score_table = train_table + '_LFM_score'
    sql = """drop table if exists {user_item_score_table};
                create table {user_item_score_table} (userid integer, scored_item json);""".format(
                user_item_score_table=user_item_score_table
                )
    plpy.execute(sql)
    
    for userid, items in user_item_score_mat.items():
        items_json = json.dumps(items)
        sql = """insert into {user_item_score_table} values ({userid}, $${items_json}$$);""".format(
            user_item_score_table=user_item_score_table,
            userid=userid,
            items_json=items_json
        )
        plpy.execute(sql)

    plpy.info('Training finish! Users\' scored items are stored in table ' + user_item_score_table)

    # 6) Test recommendation results
    if test_table:
        sql = """select {user_varname}, {item_varname} from {test_table};""".format(
                user_varname=quote_ident(user_varname),
                item_varname=quote_ident(item_varname),
                test_table=test_table
            )
        results = plpy.execute(sql)

        user_item_true_mat = defaultdict(set)
        for result in results:
            user_item_true_mat[result[user_varname]].add(result[item_varname])
        
        hit_count = 0
        rec_count = 0
        test_count = 0
        all_rec_items = set()
        popular_sum = 0

        for user in users_set:
            if user not in user_item_true_mat:
                continue
            true_items = user_item_true_mat[user]
            scored_items = user_item_score_mat[user]
            for item, _ in sorted(scored_items.items(), key=itemgetter(1), reverse=True)[:n_rec_item]:
                if item in true_items:
                    hit_count += 1
                all_rec_items.add(item)
                popular_sum += math.log(1 + item_popular[item])
            rec_count += n_rec_item
            test_count += len(true_items)
        precision = hit_count / (1.0 * rec_count)
        recall = hit_count / (1.0 * test_count)
        coverage = len(all_rec_items) / (1.0 * items_count)
        popularity = popular_sum / (1.0 * rec_count)
        plpy.info('Testing finish! Precision:', precision, 'Recall:', recall, 'Coverage:', coverage, 'Popularity:', popularity)

def predict_validate(train_table, predict_table, user_varname, recommend_table, n_rec_item):
    if not train_table or not predict_table or not user_varname or not recommend_table or not n_rec_item or n_rec_item < 1:
        plpy.error("The input parameters are invalid.")

def predict(schema_madlib, train_table, predict_table, user_varname, recommend_table, n_rec_item, **kwargs):
    
    # 0) Validate input parameters
    predict_validate(train_table, predict_table, user_varname, recommend_table, n_rec_item)

    # 1) Read user-item-score table
    sql = """select userid, scored_item from {user_item_score_table};""".format(
            user_item_score_table=train_table+'_LFM_score'
        )
    results = plpy.execute(sql)

    user_item_score_mat = {}
    for result in results:
        userid = result['userid']
        user_item_score_mat.setdefault(userid, [])
        scored_items = json.loads(result['scored_item'])
        for itemid, _ in sorted(scored_items.items(), key=itemgetter(1), reverse=True)[:n_rec_item]:
            user_item_score_mat[userid].append(itemid)
    
    # 2) Read predict table
    sql = """select {user_varname} from {predict_table};""".format(
            user_varname=quote_ident(user_varname),
            predict_table=predict_table
        )
    results = plpy.execute(sql)

    users = set()
    for result in results:
        users.add(result[user_varname])
    
    # 3) Generate recommend table
    sql = """drop table if exists {recommend_table};
                create table {recommend_table} (userid integer, recommend_item integer[]);""".format(
                recommend_table=recommend_table
                )
    plpy.execute(sql)
    
    for user in users:
        if user not in user_item_score_mat:
            plpy.info("Userid", user, "is a cold-start user!")
            continue
        recommend_item = [int(x) for x in user_item_score_mat[user]]
        sql = """insert into {recommend_table} values ({userid}, array{recommend_item});""".format(
            recommend_table=recommend_table,
            userid=user,
            recommend_item=recommend_item
        )
        plpy.execute(sql)

    plpy.info('Recommending finish! Users\' recommended items are stored in table ' + recommend_table)
