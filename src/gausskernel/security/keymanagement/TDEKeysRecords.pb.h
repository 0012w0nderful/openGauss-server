// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: TDEKeysRecords.proto
#ifndef PROTOBUF_INCLUDED_TDEKeysRecords_2eproto
#define PROTOBUF_INCLUDED_TDEKeysRecords_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>   // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_TDEKeysRecords_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_TDEKeysRecords_2eproto {
    static const ::google::protobuf::internal::ParseTableField entries[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::google::protobuf::internal::AuxillaryParseTableField aux[] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::google::protobuf::internal::ParseTable schema[1] PROTOBUF_SECTION_VARIABLE(protodesc_cold);
    static const ::google::protobuf::internal::FieldMetadata field_metadata[];
    static const ::google::protobuf::internal::SerializationTable serialization_table[];
    static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_TDEKeysRecords_2eproto();
class TDEKeysRecords;
class TDEKeysRecordsDefaultTypeInternal;
extern TDEKeysRecordsDefaultTypeInternal _TDEKeysRecords_default_instance_;
namespace google {
namespace protobuf {
template <>
::TDEKeysRecords* Arena::CreateMaybeMessage<::TDEKeysRecords>(Arena*);
}  // namespace protobuf
}  // namespace google

enum TDEKeysRecords_DEK_STATUS {
    TDEKeysRecords_DEK_STATUS_ALIVED = 1,
    TDEKeysRecords_DEK_STATUS_DEAD = 0,
    TDEKeysRecords_DEK_STATUS_INVALID = -1
};
bool TDEKeysRecords_DEK_STATUS_IsValid(int value);
const TDEKeysRecords_DEK_STATUS TDEKeysRecords_DEK_STATUS_DEK_STATUS_MIN = TDEKeysRecords_DEK_STATUS_INVALID;
const TDEKeysRecords_DEK_STATUS TDEKeysRecords_DEK_STATUS_DEK_STATUS_MAX = TDEKeysRecords_DEK_STATUS_ALIVED;
const int TDEKeysRecords_DEK_STATUS_DEK_STATUS_ARRAYSIZE = TDEKeysRecords_DEK_STATUS_DEK_STATUS_MAX + 1;

const ::google::protobuf::EnumDescriptor* TDEKeysRecords_DEK_STATUS_descriptor();
inline const ::std::string& TDEKeysRecords_DEK_STATUS_Name(TDEKeysRecords_DEK_STATUS value)
{
    return ::google::protobuf::internal::NameOfEnum(TDEKeysRecords_DEK_STATUS_descriptor(), value);
}
inline bool TDEKeysRecords_DEK_STATUS_Parse(const ::std::string& name, TDEKeysRecords_DEK_STATUS* value)
{
    return ::google::protobuf::internal::ParseNamedEnum<TDEKeysRecords_DEK_STATUS>(
        TDEKeysRecords_DEK_STATUS_descriptor(), name, value);
}
enum TDEKeysRecords_TDE_ALGO { TDEKeysRecords_TDE_ALGO_AES_CTR_128 = 1, TDEKeysRecords_TDE_ALGO_SM4_CTR_128 = 2 };
bool TDEKeysRecords_TDE_ALGO_IsValid(int value);
const TDEKeysRecords_TDE_ALGO TDEKeysRecords_TDE_ALGO_TDE_ALGO_MIN = TDEKeysRecords_TDE_ALGO_AES_CTR_128;
const TDEKeysRecords_TDE_ALGO TDEKeysRecords_TDE_ALGO_TDE_ALGO_MAX = TDEKeysRecords_TDE_ALGO_SM4_CTR_128;
const int TDEKeysRecords_TDE_ALGO_TDE_ALGO_ARRAYSIZE = TDEKeysRecords_TDE_ALGO_TDE_ALGO_MAX + 1;

const ::google::protobuf::EnumDescriptor* TDEKeysRecords_TDE_ALGO_descriptor();
inline const ::std::string& TDEKeysRecords_TDE_ALGO_Name(TDEKeysRecords_TDE_ALGO value)
{
    return ::google::protobuf::internal::NameOfEnum(TDEKeysRecords_TDE_ALGO_descriptor(), value);
}
inline bool TDEKeysRecords_TDE_ALGO_Parse(const ::std::string& name, TDEKeysRecords_TDE_ALGO* value)
{
    return ::google::protobuf::internal::ParseNamedEnum<TDEKeysRecords_TDE_ALGO>(
        TDEKeysRecords_TDE_ALGO_descriptor(), name, value);
}
// ===================================================================
class TDEKeysRecords
    : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:TDEKeysRecords) */ {
public:
    TDEKeysRecords();
    virtual ~TDEKeysRecords();

    TDEKeysRecords(const TDEKeysRecords& from);

    inline TDEKeysRecords& operator=(const TDEKeysRecords& from)
    {
        CopyFrom(from);
        return *this;
    }
#if LANG_CXX11
    TDEKeysRecords(TDEKeysRecords&& from) noexcept : TDEKeysRecords()
    {
        *this = ::std::move(from);
    }

    inline TDEKeysRecords& operator=(TDEKeysRecords&& from) noexcept
    {
        if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
            if (this != &from)
                InternalSwap(&from);
        } else {
            CopyFrom(from);
        }
        return *this;
    }
#endif
    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
    {
        return _internal_metadata_.unknown_fields();
    }
    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
    {
        return _internal_metadata_.mutable_unknown_fields();
    }

    static const ::google::protobuf::Descriptor* descriptor()
    {
        return default_instance().GetDescriptor();
    }
    static const TDEKeysRecords& default_instance();

    static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
    static inline const TDEKeysRecords* internal_default_instance()
    {
        return reinterpret_cast<const TDEKeysRecords*>(&_TDEKeysRecords_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;

    void Swap(TDEKeysRecords* other);
    friend void swap(TDEKeysRecords& a, TDEKeysRecords& b)
    {
        a.Swap(&b);
    }

    // implements Message ----------------------------------------------
    inline TDEKeysRecords* New() const final
    {
        return CreateMaybeMessage<TDEKeysRecords>(nullptr);
    }

    TDEKeysRecords* New(::google::protobuf::Arena* arena) const final
    {
        return CreateMaybeMessage<TDEKeysRecords>(arena);
    }
    void CopyFrom(const ::google::protobuf::Message& from) final;
    void MergeFrom(const ::google::protobuf::Message& from) final;
    void CopyFrom(const TDEKeysRecords& from);
    void MergeFrom(const TDEKeysRecords& from);
    PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
    bool IsInitialized() const final;

    size_t ByteSizeLong() const final;
#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
    static const char* _InternalParse(
        const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
    ::google::protobuf::internal::ParseFunc _ParseFunc() const final
    {
        return _InternalParse;
    }
#else
    bool MergePartialFromCodedStream(::google::protobuf::io::CodedInputStream* input) final;
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
    void SerializeWithCachedSizes(::google::protobuf::io::CodedOutputStream* output) const final;
    ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(::google::protobuf::uint8* target) const final;
    int GetCachedSize() const final
    {
        return _cached_size_.Get();
    }

private:
    void SharedCtor();
    void SharedDtor();
    void SetCachedSize(int size) const final;
    void InternalSwap(TDEKeysRecords* other);

private:
    inline ::google::protobuf::Arena* GetArenaNoVirtual() const
    {
        return nullptr;
    }
    inline void* MaybeArenaPtr() const
    {
        return nullptr;
    }

public:
    ::google::protobuf::Metadata GetMetadata() const final;

    // nested types ----------------------------------------------------
    typedef TDEKeysRecords_DEK_STATUS DEK_STATUS;
    static const DEK_STATUS ALIVED = TDEKeysRecords_DEK_STATUS_ALIVED;
    static const DEK_STATUS DEAD = TDEKeysRecords_DEK_STATUS_DEAD;
    static const DEK_STATUS INVALID = TDEKeysRecords_DEK_STATUS_INVALID;
    static inline bool DEK_STATUS_IsValid(int value)
    {
        return TDEKeysRecords_DEK_STATUS_IsValid(value);
    }
    static const DEK_STATUS DEK_STATUS_MIN = TDEKeysRecords_DEK_STATUS_DEK_STATUS_MIN;
    static const DEK_STATUS DEK_STATUS_MAX = TDEKeysRecords_DEK_STATUS_DEK_STATUS_MAX;
    static const int DEK_STATUS_ARRAYSIZE = TDEKeysRecords_DEK_STATUS_DEK_STATUS_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor* DEK_STATUS_descriptor()
    {
        return TDEKeysRecords_DEK_STATUS_descriptor();
    }
    static inline const ::std::string& DEK_STATUS_Name(DEK_STATUS value)
    {
        return TDEKeysRecords_DEK_STATUS_Name(value);
    }
    static inline bool DEK_STATUS_Parse(const ::std::string& name, DEK_STATUS* value)
    {
        return TDEKeysRecords_DEK_STATUS_Parse(name, value);
    }

    typedef TDEKeysRecords_TDE_ALGO TDE_ALGO;
    static const TDE_ALGO AES_CTR_128 = TDEKeysRecords_TDE_ALGO_AES_CTR_128;
    static const TDE_ALGO SM4_CTR_128 = TDEKeysRecords_TDE_ALGO_SM4_CTR_128;
    static inline bool TDE_ALGO_IsValid(int value)
    {
        return TDEKeysRecords_TDE_ALGO_IsValid(value);
    }
    static const TDE_ALGO TDE_ALGO_MIN = TDEKeysRecords_TDE_ALGO_TDE_ALGO_MIN;
    static const TDE_ALGO TDE_ALGO_MAX = TDEKeysRecords_TDE_ALGO_TDE_ALGO_MAX;
    static const int TDE_ALGO_ARRAYSIZE = TDEKeysRecords_TDE_ALGO_TDE_ALGO_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor* TDE_ALGO_descriptor()
    {
        return TDEKeysRecords_TDE_ALGO_descriptor();
    }
    static inline const ::std::string& TDE_ALGO_Name(TDE_ALGO value)
    {
        return TDEKeysRecords_TDE_ALGO_Name(value);
    }
    static inline bool TDE_ALGO_Parse(const ::std::string& name, TDE_ALGO* value)
    {
        return TDEKeysRecords_TDE_ALGO_Parse(name, value);
    }

    // accessors -------------------------------------------------------
    // repeated fixed32 DEK_IV = 10;
    int dek_iv_size() const;
    void clear_dek_iv();
    static const int kDEKIVFieldNumber = 10;
    ::google::protobuf::uint32 dek_iv(int index) const;
    void set_dek_iv(int index, ::google::protobuf::uint32 value);
    void add_dek_iv(::google::protobuf::uint32 value);
    const ::google::protobuf::RepeatedField<::google::protobuf::uint32>& dek_iv() const;
    ::google::protobuf::RepeatedField<::google::protobuf::uint32>* mutable_dek_iv();

    // required bytes table_id = 1;
    bool has_table_id() const;
    void clear_table_id();
    static const int kTableIdFieldNumber = 1;
    const ::std::string& table_id() const;
    void set_table_id(const ::std::string& value);
#if LANG_CXX11
    void set_table_id(::std::string&& value);
#endif
    void set_table_id(const char* value);
    void set_table_id(const void* value, size_t size);
    ::std::string* mutable_table_id();
    ::std::string* release_table_id();
    void set_allocated_table_id(::std::string* table_id);

    // required bytes database_id = 2;
    bool has_database_id() const;
    void clear_database_id();
    static const int kDatabaseIdFieldNumber = 2;
    const ::std::string& database_id() const;
    void set_database_id(const ::std::string& value);
#if LANG_CXX11
    void set_database_id(::std::string&& value);
#endif
    void set_database_id(const char* value);
    void set_database_id(const void* value, size_t size);
    ::std::string* mutable_database_id();
    ::std::string* release_database_id();
    void set_allocated_database_id(::std::string* database_id);

    // required bytes CEK_name = 4;
    bool has_cek_name() const;
    void clear_cek_name();
    static const int kCEKNameFieldNumber = 4;
    const ::std::string& cek_name() const;
    void set_cek_name(const ::std::string& value);
#if LANG_CXX11
    void set_cek_name(::std::string&& value);
#endif
    void set_cek_name(const char* value);
    void set_cek_name(const void* value, size_t size);
    ::std::string* mutable_cek_name();
    ::std::string* release_cek_name();
    void set_allocated_cek_name(::std::string* cek_name);

    // required bytes CEK_version = 5;
    bool has_cek_version() const;
    void clear_cek_version();
    static const int kCEKVersionFieldNumber = 5;
    const ::std::string& cek_version() const;
    void set_cek_version(const ::std::string& value);
#if LANG_CXX11
    void set_cek_version(::std::string&& value);
#endif
    void set_cek_version(const char* value);
    void set_cek_version(const void* value, size_t size);
    ::std::string* mutable_cek_version();
    ::std::string* release_cek_version();
    void set_allocated_cek_version(::std::string* cek_version);

    // required bytes CEK_IV = 6;
    bool has_cek_iv() const;
    void clear_cek_iv();
    static const int kCEKIVFieldNumber = 6;
    const ::std::string& cek_iv() const;
    void set_cek_iv(const ::std::string& value);
#if LANG_CXX11
    void set_cek_iv(::std::string&& value);
#endif
    void set_cek_iv(const char* value);
    void set_cek_iv(const void* value, size_t size);
    ::std::string* mutable_cek_iv();
    ::std::string* release_cek_iv();
    void set_allocated_cek_iv(::std::string* cek_iv);

    // required bytes encrypted_sample_string = 7;
    bool has_encrypted_sample_string() const;
    void clear_encrypted_sample_string();
    static const int kEncryptedSampleStringFieldNumber = 7;
    const ::std::string& encrypted_sample_string() const;
    void set_encrypted_sample_string(const ::std::string& value);
#if LANG_CXX11
    void set_encrypted_sample_string(::std::string&& value);
#endif
    void set_encrypted_sample_string(const char* value);
    void set_encrypted_sample_string(const void* value, size_t size);
    ::std::string* mutable_encrypted_sample_string();
    ::std::string* release_encrypted_sample_string();
    void set_allocated_encrypted_sample_string(::std::string* encrypted_sample_string);

    // required bytes DEK_cipher = 8;
    bool has_dek_cipher() const;
    void clear_dek_cipher();
    static const int kDEKCipherFieldNumber = 8;
    const ::std::string& dek_cipher() const;
    void set_dek_cipher(const ::std::string& value);
#if LANG_CXX11
    void set_dek_cipher(::std::string&& value);
#endif
    void set_dek_cipher(const char* value);
    void set_dek_cipher(const void* value, size_t size);
    ::std::string* mutable_dek_cipher();
    ::std::string* release_dek_cipher();
    void set_allocated_dek_cipher(::std::string* dek_cipher);

    bool has_dek_status() const;
    void clear_dek_status();
    static const int kDEKStatusFieldNumber = 3;
    ::TDEKeysRecords_DEK_STATUS dek_status() const;
    void set_dek_status(::TDEKeysRecords_DEK_STATUS value);

    bool has_algo() const;
    void clear_algo();
    static const int kAlgoFieldNumber = 9;
    ::TDEKeysRecords_TDE_ALGO algo() const;
    void set_algo(::TDEKeysRecords_TDE_ALGO value);

    // @@protoc_insertion_point(class_scope:TDEKeysRecords)
private:
    class HasBitSetters;

    // helper for ByteSizeLong()
    size_t RequiredFieldsByteSizeFallback() const;

    ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::RepeatedField<::google::protobuf::uint32> dek_iv_;
    ::google::protobuf::internal::ArenaStringPtr table_id_;
    ::google::protobuf::internal::ArenaStringPtr database_id_;
    ::google::protobuf::internal::ArenaStringPtr cek_name_;
    ::google::protobuf::internal::ArenaStringPtr cek_version_;
    ::google::protobuf::internal::ArenaStringPtr cek_iv_;
    ::google::protobuf::internal::ArenaStringPtr encrypted_sample_string_;
    ::google::protobuf::internal::ArenaStringPtr dek_cipher_;
    int dek_status_;
    int algo_;
    friend struct ::TableStruct_TDEKeysRecords_2eproto;
};
// ===================================================================
// ===================================================================
#ifdef __GNUC__
#pragma GCC diagnostic push
#endif  // __GNUC__
// TDEKeysRecords
// required bytes table_id = 1;
inline bool TDEKeysRecords::has_table_id() const
{
    return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TDEKeysRecords::clear_table_id()
{
    table_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& TDEKeysRecords::table_id() const
{
    // @@protoc_insertion_point(field_get:TDEKeysRecords.table_id)
    return table_id_.GetNoArena();
}
inline void TDEKeysRecords::set_table_id(const ::std::string& value)
{
    _has_bits_[0] |= 0x00000001u;
    table_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:TDEKeysRecords.table_id)
}
#if LANG_CXX11
inline void TDEKeysRecords::set_table_id(::std::string&& value)
{
    _has_bits_[0] |= 0x00000001u;
    table_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:TDEKeysRecords.table_id)
}
#endif
inline void TDEKeysRecords::set_table_id(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000001u;
    table_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:TDEKeysRecords.table_id)
}
inline void TDEKeysRecords::set_table_id(const void* value, size_t size)
{
    _has_bits_[0] |= 0x00000001u;
    table_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:TDEKeysRecords.table_id)
}
inline ::std::string* TDEKeysRecords::mutable_table_id()
{
    _has_bits_[0] |= 0x00000001u;
    // @@protoc_insertion_point(field_mutable:TDEKeysRecords.table_id)
    return table_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TDEKeysRecords::release_table_id()
{
    // @@protoc_insertion_point(field_release:TDEKeysRecords.table_id)
    if (!has_table_id()) {
        return nullptr;
    }
    _has_bits_[0] &= ~0x00000001u;
    return table_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TDEKeysRecords::set_allocated_table_id(::std::string* table_id)
{
    if (table_id != nullptr) {
        _has_bits_[0] |= 0x00000001u;
    } else {
        _has_bits_[0] &= ~0x00000001u;
    }
    table_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), table_id);
    // @@protoc_insertion_point(field_set_allocated:TDEKeysRecords.table_id)
}

// required bytes database_id = 2;
inline bool TDEKeysRecords::has_database_id() const
{
    return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TDEKeysRecords::clear_database_id()
{
    database_id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    _has_bits_[0] &= ~0x00000002u;
}
inline const ::std::string& TDEKeysRecords::database_id() const
{
    // @@protoc_insertion_point(field_get:TDEKeysRecords.database_id)
    return database_id_.GetNoArena();
}
inline void TDEKeysRecords::set_database_id(const ::std::string& value)
{
    _has_bits_[0] |= 0x00000002u;
    database_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:TDEKeysRecords.database_id)
}
#if LANG_CXX11
inline void TDEKeysRecords::set_database_id(::std::string&& value)
{
    _has_bits_[0] |= 0x00000002u;
    database_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:TDEKeysRecords.database_id)
}
#endif
inline void TDEKeysRecords::set_database_id(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000002u;
    database_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:TDEKeysRecords.database_id)
}
inline void TDEKeysRecords::set_database_id(const void* value, size_t size)
{
    _has_bits_[0] |= 0x00000002u;
    database_id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:TDEKeysRecords.database_id)
}
inline ::std::string* TDEKeysRecords::mutable_database_id()
{
    _has_bits_[0] |= 0x00000002u;
    // @@protoc_insertion_point(field_mutable:TDEKeysRecords.database_id)
    return database_id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TDEKeysRecords::release_database_id()
{
    // @@protoc_insertion_point(field_release:TDEKeysRecords.database_id)
    if (!has_database_id()) {
        return nullptr;
    }
    _has_bits_[0] &= ~0x00000002u;
    return database_id_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TDEKeysRecords::set_allocated_database_id(::std::string* database_id)
{
    if (database_id != nullptr) {
        _has_bits_[0] |= 0x00000002u;
    } else {
        _has_bits_[0] &= ~0x00000002u;
    }
    database_id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), database_id);
    // @@protoc_insertion_point(field_set_allocated:TDEKeysRecords.database_id)
}

inline bool TDEKeysRecords::has_dek_status() const
{
    return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TDEKeysRecords::clear_dek_status()
{
    dek_status_ = 0;
    _has_bits_[0] &= ~0x00000080u;
}
inline ::TDEKeysRecords_DEK_STATUS TDEKeysRecords::dek_status() const
{
    // @@protoc_insertion_point(field_get:TDEKeysRecords.DEK_status)
    return static_cast<::TDEKeysRecords_DEK_STATUS>(dek_status_);
}
inline void TDEKeysRecords::set_dek_status(::TDEKeysRecords_DEK_STATUS value)
{
    assert(::TDEKeysRecords_DEK_STATUS_IsValid(value));
    _has_bits_[0] |= 0x00000080u;
    dek_status_ = value;
    // @@protoc_insertion_point(field_set:TDEKeysRecords.DEK_status)
}

// required bytes CEK_name = 4;
inline bool TDEKeysRecords::has_cek_name() const
{
    return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TDEKeysRecords::clear_cek_name()
{
    cek_name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    _has_bits_[0] &= ~0x00000004u;
}
inline const ::std::string& TDEKeysRecords::cek_name() const
{
    // @@protoc_insertion_point(field_get:TDEKeysRecords.CEK_name)
    return cek_name_.GetNoArena();
}
inline void TDEKeysRecords::set_cek_name(const ::std::string& value)
{
    _has_bits_[0] |= 0x00000004u;
    cek_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:TDEKeysRecords.CEK_name)
}
#if LANG_CXX11
inline void TDEKeysRecords::set_cek_name(::std::string&& value)
{
    _has_bits_[0] |= 0x00000004u;
    cek_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:TDEKeysRecords.CEK_name)
}
#endif
inline void TDEKeysRecords::set_cek_name(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000004u;
    cek_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:TDEKeysRecords.CEK_name)
}
inline void TDEKeysRecords::set_cek_name(const void* value, size_t size)
{
    _has_bits_[0] |= 0x00000004u;
    cek_name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:TDEKeysRecords.CEK_name)
}
inline ::std::string* TDEKeysRecords::mutable_cek_name()
{
    _has_bits_[0] |= 0x00000004u;
    // @@protoc_insertion_point(field_mutable:TDEKeysRecords.CEK_name)
    return cek_name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TDEKeysRecords::release_cek_name()
{
    // @@protoc_insertion_point(field_release:TDEKeysRecords.CEK_name)
    if (!has_cek_name()) {
        return nullptr;
    }
    _has_bits_[0] &= ~0x00000004u;
    return cek_name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TDEKeysRecords::set_allocated_cek_name(::std::string* cek_name)
{
    if (cek_name != nullptr) {
        _has_bits_[0] |= 0x00000004u;
    } else {
        _has_bits_[0] &= ~0x00000004u;
    }
    cek_name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cek_name);
    // @@protoc_insertion_point(field_set_allocated:TDEKeysRecords.CEK_name)
}

// required bytes CEK_version = 5;
inline bool TDEKeysRecords::has_cek_version() const
{
    return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TDEKeysRecords::clear_cek_version()
{
    cek_version_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    _has_bits_[0] &= ~0x00000008u;
}
inline const ::std::string& TDEKeysRecords::cek_version() const
{
    // @@protoc_insertion_point(field_get:TDEKeysRecords.CEK_version)
    return cek_version_.GetNoArena();
}
inline void TDEKeysRecords::set_cek_version(const ::std::string& value)
{
    _has_bits_[0] |= 0x00000008u;
    cek_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:TDEKeysRecords.CEK_version)
}
#if LANG_CXX11
inline void TDEKeysRecords::set_cek_version(::std::string&& value)
{
    _has_bits_[0] |= 0x00000008u;
    cek_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:TDEKeysRecords.CEK_version)
}
#endif
inline void TDEKeysRecords::set_cek_version(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000008u;
    cek_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:TDEKeysRecords.CEK_version)
}
inline void TDEKeysRecords::set_cek_version(const void* value, size_t size)
{
    _has_bits_[0] |= 0x00000008u;
    cek_version_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:TDEKeysRecords.CEK_version)
}
inline ::std::string* TDEKeysRecords::mutable_cek_version()
{
    _has_bits_[0] |= 0x00000008u;
    // @@protoc_insertion_point(field_mutable:TDEKeysRecords.CEK_version)
    return cek_version_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TDEKeysRecords::release_cek_version()
{
    // @@protoc_insertion_point(field_release:TDEKeysRecords.CEK_version)
    if (!has_cek_version()) {
        return nullptr;
    }
    _has_bits_[0] &= ~0x00000008u;
    return cek_version_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TDEKeysRecords::set_allocated_cek_version(::std::string* cek_version)
{
    if (cek_version != nullptr) {
        _has_bits_[0] |= 0x00000008u;
    } else {
        _has_bits_[0] &= ~0x00000008u;
    }
    cek_version_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cek_version);
    // @@protoc_insertion_point(field_set_allocated:TDEKeysRecords.CEK_version)
}

// required bytes CEK_IV = 6;
inline bool TDEKeysRecords::has_cek_iv() const
{
    return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TDEKeysRecords::clear_cek_iv()
{
    cek_iv_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    _has_bits_[0] &= ~0x00000010u;
}
inline const ::std::string& TDEKeysRecords::cek_iv() const
{
    // @@protoc_insertion_point(field_get:TDEKeysRecords.CEK_IV)
    return cek_iv_.GetNoArena();
}
inline void TDEKeysRecords::set_cek_iv(const ::std::string& value)
{
    _has_bits_[0] |= 0x00000010u;
    cek_iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:TDEKeysRecords.CEK_IV)
}
#if LANG_CXX11
inline void TDEKeysRecords::set_cek_iv(::std::string&& value)
{
    _has_bits_[0] |= 0x00000010u;
    cek_iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:TDEKeysRecords.CEK_IV)
}
#endif
inline void TDEKeysRecords::set_cek_iv(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000010u;
    cek_iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:TDEKeysRecords.CEK_IV)
}
inline void TDEKeysRecords::set_cek_iv(const void* value, size_t size)
{
    _has_bits_[0] |= 0x00000010u;
    cek_iv_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:TDEKeysRecords.CEK_IV)
}
inline ::std::string* TDEKeysRecords::mutable_cek_iv()
{
    _has_bits_[0] |= 0x00000010u;
    // @@protoc_insertion_point(field_mutable:TDEKeysRecords.CEK_IV)
    return cek_iv_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TDEKeysRecords::release_cek_iv()
{
    // @@protoc_insertion_point(field_release:TDEKeysRecords.CEK_IV)
    if (!has_cek_iv()) {
        return nullptr;
    }
    _has_bits_[0] &= ~0x00000010u;
    return cek_iv_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TDEKeysRecords::set_allocated_cek_iv(::std::string* cek_iv)
{
    if (cek_iv != nullptr) {
        _has_bits_[0] |= 0x00000010u;
    } else {
        _has_bits_[0] &= ~0x00000010u;
    }
    cek_iv_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cek_iv);
    // @@protoc_insertion_point(field_set_allocated:TDEKeysRecords.CEK_IV)
}

// required bytes encrypted_sample_string = 7;
inline bool TDEKeysRecords::has_encrypted_sample_string() const
{
    return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TDEKeysRecords::clear_encrypted_sample_string()
{
    encrypted_sample_string_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    _has_bits_[0] &= ~0x00000020u;
}
inline const ::std::string& TDEKeysRecords::encrypted_sample_string() const
{
    // @@protoc_insertion_point(field_get:TDEKeysRecords.encrypted_sample_string)
    return encrypted_sample_string_.GetNoArena();
}
inline void TDEKeysRecords::set_encrypted_sample_string(const ::std::string& value)
{
    _has_bits_[0] |= 0x00000020u;
    encrypted_sample_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:TDEKeysRecords.encrypted_sample_string)
}
#if LANG_CXX11
inline void TDEKeysRecords::set_encrypted_sample_string(::std::string&& value)
{
    _has_bits_[0] |= 0x00000020u;
    encrypted_sample_string_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:TDEKeysRecords.encrypted_sample_string)
}
#endif
inline void TDEKeysRecords::set_encrypted_sample_string(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000020u;
    encrypted_sample_string_.SetNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:TDEKeysRecords.encrypted_sample_string)
}
inline void TDEKeysRecords::set_encrypted_sample_string(const void* value, size_t size)
{
    _has_bits_[0] |= 0x00000020u;
    encrypted_sample_string_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:TDEKeysRecords.encrypted_sample_string)
}
inline ::std::string* TDEKeysRecords::mutable_encrypted_sample_string()
{
    _has_bits_[0] |= 0x00000020u;
    // @@protoc_insertion_point(field_mutable:TDEKeysRecords.encrypted_sample_string)
    return encrypted_sample_string_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TDEKeysRecords::release_encrypted_sample_string()
{
    // @@protoc_insertion_point(field_release:TDEKeysRecords.encrypted_sample_string)
    if (!has_encrypted_sample_string()) {
        return nullptr;
    }
    _has_bits_[0] &= ~0x00000020u;
    return encrypted_sample_string_.ReleaseNonDefaultNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TDEKeysRecords::set_allocated_encrypted_sample_string(::std::string* encrypted_sample_string)
{
    if (encrypted_sample_string != nullptr) {
        _has_bits_[0] |= 0x00000020u;
    } else {
        _has_bits_[0] &= ~0x00000020u;
    }
    encrypted_sample_string_.SetAllocatedNoArena(
        &::google::protobuf::internal::GetEmptyStringAlreadyInited(), encrypted_sample_string);
    // @@protoc_insertion_point(field_set_allocated:TDEKeysRecords.encrypted_sample_string)
}

// required bytes DEK_cipher = 8;
inline bool TDEKeysRecords::has_dek_cipher() const
{
    return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TDEKeysRecords::clear_dek_cipher()
{
    dek_cipher_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    _has_bits_[0] &= ~0x00000040u;
}
inline const ::std::string& TDEKeysRecords::dek_cipher() const
{
    // @@protoc_insertion_point(field_get:TDEKeysRecords.DEK_cipher)
    return dek_cipher_.GetNoArena();
}
inline void TDEKeysRecords::set_dek_cipher(const ::std::string& value)
{
    _has_bits_[0] |= 0x00000040u;
    dek_cipher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
    // @@protoc_insertion_point(field_set:TDEKeysRecords.DEK_cipher)
}
#if LANG_CXX11
inline void TDEKeysRecords::set_dek_cipher(::std::string&& value)
{
    _has_bits_[0] |= 0x00000040u;
    dek_cipher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
    // @@protoc_insertion_point(field_set_rvalue:TDEKeysRecords.DEK_cipher)
}
#endif
inline void TDEKeysRecords::set_dek_cipher(const char* value)
{
    GOOGLE_DCHECK(value != nullptr);
    _has_bits_[0] |= 0x00000040u;
    dek_cipher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
    // @@protoc_insertion_point(field_set_char:TDEKeysRecords.DEK_cipher)
}
inline void TDEKeysRecords::set_dek_cipher(const void* value, size_t size)
{
    _has_bits_[0] |= 0x00000040u;
    dek_cipher_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        ::std::string(reinterpret_cast<const char*>(value), size));
    // @@protoc_insertion_point(field_set_pointer:TDEKeysRecords.DEK_cipher)
}
inline ::std::string* TDEKeysRecords::mutable_dek_cipher()
{
    _has_bits_[0] |= 0x00000040u;
    // @@protoc_insertion_point(field_mutable:TDEKeysRecords.DEK_cipher)
    return dek_cipher_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TDEKeysRecords::release_dek_cipher()
{
    // @@protoc_insertion_point(field_release:TDEKeysRecords.DEK_cipher)
    if (!has_dek_cipher()) {
        return nullptr;
    }
    _has_bits_[0] &= ~0x00000040u;
    return dek_cipher_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TDEKeysRecords::set_allocated_dek_cipher(::std::string* dek_cipher)
{
    if (dek_cipher != nullptr) {
        _has_bits_[0] |= 0x00000040u;
    } else {
        _has_bits_[0] &= ~0x00000040u;
    }
    dek_cipher_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), dek_cipher);
    // @@protoc_insertion_point(field_set_allocated:TDEKeysRecords.DEK_cipher)
}

// repeated fixed32 DEK_IV = 10;
inline int TDEKeysRecords::dek_iv_size() const
{
    return dek_iv_.size();
}

inline void TDEKeysRecords::clear_dek_iv()
{
    dek_iv_.Clear();
}

inline ::google::protobuf::uint32 TDEKeysRecords::dek_iv(int index) const
{
    return dek_iv_.Get(index);
}

inline void TDEKeysRecords::set_dek_iv(int index, ::google::protobuf::uint32 value)
{
    dek_iv_.Set(index, value);
}

inline void TDEKeysRecords::add_dek_iv(::google::protobuf::uint32 value)
{
    dek_iv_.Add(value);
}

inline const ::google::protobuf::RepeatedField<::google::protobuf::uint32>& TDEKeysRecords::dek_iv() const
{
    return dek_iv_;
}

inline ::google::protobuf::RepeatedField<::google::protobuf::uint32>* TDEKeysRecords::mutable_dek_iv()
{
    return &dek_iv_;
}

inline bool TDEKeysRecords::has_algo() const
{
    return (_has_bits_[0] & 0x00000100u) != 0;
}

inline void TDEKeysRecords::clear_algo()
{
    algo_ = 1;
    _has_bits_[0] &= ~0x00000100u;
}

inline ::TDEKeysRecords_TDE_ALGO TDEKeysRecords::algo() const
{
    return static_cast<::TDEKeysRecords_TDE_ALGO>(algo_);
}

inline void TDEKeysRecords::set_algo(::TDEKeysRecords_TDE_ALGO value)
{
    assert(::TDEKeysRecords_TDE_ALGO_IsValid(value));
    _has_bits_[0] |= 0x00000100u;
    algo_ = value;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::TDEKeysRecords_DEK_STATUS> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::TDEKeysRecords_DEK_STATUS>()
{
    return ::TDEKeysRecords_DEK_STATUS_descriptor();
}
template <>
struct is_proto_enum<::TDEKeysRecords_TDE_ALGO> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::TDEKeysRecords_TDE_ALGO>()
{
    return ::TDEKeysRecords_TDE_ALGO_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_TDEKeysRecords_2eproto
